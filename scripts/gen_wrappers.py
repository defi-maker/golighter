#!/usr/bin/env python3
"""Generate thin wrappers around the oapi-codegen client.

The script reads api/lighter.gen.go and emits client/generated_wrappers.go.
"""
from __future__ import annotations

import argparse
import re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
API_FILE = ROOT / "api" / "lighter.gen.go"
OUT_FILE = ROOT / "client" / "generated_wrappers.go"

STRUCT_PATTERN = re.compile(r"type (\\w+) struct {", re.MULTILINE)
JSON_PATTERN = re.compile(r"\\tJSON200\\s+\\*(\\w+)")
METHOD_PATTERN = re.compile(
    r"(?P<name>\\w+WithResponse)\\(ctx context.Context(?P<params>[^)]*)\\) \\(\\*(?P<resp>\\w+), error\\)"
)
PARAM_PATTERN = re.compile(r"params \\(\\*(\\w+)\\)")


def build_response_map(source: str) -> dict[str, str]:
    response_map: dict[str, str] = {}
    for struct_match in STRUCT_PATTERN.finditer(source):
        name = struct_match.group(1)
        block_start = struct_match.end()
        block_end = source.find('}', block_start)
        if block_end == -1:
            continue
        block = source[block_start:block_end]
        json_match = JSON_PATTERN.search(block)
        if json_match:
            response_map[name] = json_match.group(1)
    return response_map


def build_methods(lines: list[str], response_map: dict[str, str]) -> list[tuple[str, str | None, str]]:
    start = end = None
    for idx, line in enumerate(lines):
        if 'type ClientWithResponsesInterface interface {' in line:
            start = idx + 1
            break
    if start is None:
        raise RuntimeError('ClientWithResponsesInterface not found')
    for idx in range(start, len(lines)):
        if lines[idx].strip() == '}':
            end = idx
            break
    if end is None:
        raise RuntimeError('end of interface not found')

    methods: list[tuple[str, str | None, str]] = []
    for line in lines[start:end]:
        stripped = line.strip()
        if not stripped or stripped.startswith('//'):
            continue
        match = METHOD_PATTERN.match(stripped)
        if not match:
            continue
        name_with_resp = match.group('name')
        if 'WithBody' in name_with_resp:
            continue
        params_part = match.group('params')
        params_type = None
        for part in params_part.split(','):
            part = part.strip()
            param_match = PARAM_PATTERN.match(part)
            if param_match:
                params_type = param_match.group(1)
                break
        resp_type = match.group('resp')
        json_type = response_map.get(resp_type)
        if not json_type:
            raise RuntimeError(f'JSON200 type not found for {resp_type}')
        method_name = name_with_resp[:-len('WithResponse')]
        methods.append((method_name, params_type, json_type))
    return methods


def render(methods: list[tuple[str, str | None, str]]) -> str:
    parts = [
        "// Code generated by scripts/gen_wrappers.py; DO NOT EDIT.\n",
        "package client\n\n",
        "import (\n    \"context\"\n\n    lighterapi \"github.com/defi-maker/golighter/api\"\n)\n\n",
    ]
    for name, params_type, json_type in methods:
        sig_params = ["ctx context.Context"]
        call_args = ["ctx"]
        if params_type:
            sig_params.append(f"params *lighterapi.{params_type}")
            call_args.append("params")
        parts.append(f"func (c *Client) {name}({', '.join(sig_params)}) (*lighterapi.{json_type}, error) {{\n")
        parts.append(f"    resp, err := c.api.{name}WithResponse({', '.join(call_args)})\n")
        parts.append("    if err != nil {\n        return nil, err\n    }\n")
        parts.append("    if resp.JSON200 != nil {\n        return resp.JSON200, nil\n    }\n")
        parts.append("    return nil, resultCodeError(resp.StatusCode(), resp.Body, resp.JSON400)\n")
        parts.append("}\n\n")
    return ''.join(parts)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.parse_args()

    source_text = API_FILE.read_text()
    response_map = build_response_map(source_text)
    methods = build_methods(source_text.splitlines(), response_map)
    OUT_FILE.write_text(render(methods))


if __name__ == "__main__":
    main()
