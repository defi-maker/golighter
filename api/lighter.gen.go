// Package lighterapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package lighterapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for DepositHistoryItemStatus.
const (
	DepositHistoryItemStatusClaimable DepositHistoryItemStatus = "claimable"
	DepositHistoryItemStatusCompleted DepositHistoryItemStatus = "completed"
	DepositHistoryItemStatusFailed    DepositHistoryItemStatus = "failed"
	DepositHistoryItemStatusPending   DepositHistoryItemStatus = "pending"
)

// Defines values for FundingRateExchange.
const (
	Binance     FundingRateExchange = "binance"
	Bybit       FundingRateExchange = "bybit"
	Hyperliquid FundingRateExchange = "hyperliquid"
	Lighter     FundingRateExchange = "lighter"
)

// Defines values for LiquidationType.
const (
	LiquidationTypeDeleverage LiquidationType = "deleverage"
	LiquidationTypePartial    LiquidationType = "partial"
)

// Defines values for OrderStatus.
const (
	OrderStatusCanceled                   OrderStatus = "canceled"
	OrderStatusCanceledChild              OrderStatus = "canceled-child"
	OrderStatusCanceledExpired            OrderStatus = "canceled-expired"
	OrderStatusCanceledLiquidation        OrderStatus = "canceled-liquidation"
	OrderStatusCanceledMarginNotAllowed   OrderStatus = "canceled-margin-not-allowed"
	OrderStatusCanceledNotEnoughLiquidity OrderStatus = "canceled-not-enough-liquidity"
	OrderStatusCanceledOco                OrderStatus = "canceled-oco"
	OrderStatusCanceledPositionNotAllowed OrderStatus = "canceled-position-not-allowed"
	OrderStatusCanceledPostOnly           OrderStatus = "canceled-post-only"
	OrderStatusCanceledReduceOnly         OrderStatus = "canceled-reduce-only"
	OrderStatusCanceledSelfTrade          OrderStatus = "canceled-self-trade"
	OrderStatusCanceledTooMuchSlippage    OrderStatus = "canceled-too-much-slippage"
	OrderStatusFilled                     OrderStatus = "filled"
	OrderStatusInProgress                 OrderStatus = "in-progress"
	OrderStatusOpen                       OrderStatus = "open"
	OrderStatusPending                    OrderStatus = "pending"
)

// Defines values for OrderTimeInForce.
const (
	GoodTillTime      OrderTimeInForce = "good-till-time"
	ImmediateOrCancel OrderTimeInForce = "immediate-or-cancel"
	PostOnly          OrderTimeInForce = "post-only"
	Unknown           OrderTimeInForce = "Unknown"
)

// Defines values for OrderTriggerStatus.
const (
	OrderTriggerStatusMarkPrice   OrderTriggerStatus = "mark-price"
	OrderTriggerStatusNa          OrderTriggerStatus = "na"
	OrderTriggerStatusParentOrder OrderTriggerStatus = "parent-order"
	OrderTriggerStatusReady       OrderTriggerStatus = "ready"
	OrderTriggerStatusTwap        OrderTriggerStatus = "twap"
)

// Defines values for OrderType.
const (
	OrderTypeLimit           OrderType = "limit"
	OrderTypeLiquidation     OrderType = "liquidation"
	OrderTypeMarket          OrderType = "market"
	OrderTypeStopLoss        OrderType = "stop-loss"
	OrderTypeStopLossLimit   OrderType = "stop-loss-limit"
	OrderTypeTakeProfit      OrderType = "take-profit"
	OrderTypeTakeProfitLimit OrderType = "take-profit-limit"
	OrderTypeTwap            OrderType = "twap"
	OrderTypeTwapSub         OrderType = "twap-sub"
)

// Defines values for OrderBookStatus.
const (
	OrderBookStatusActive   OrderBookStatus = "active"
	OrderBookStatusFrozen   OrderBookStatus = "frozen"
	OrderBookStatusInactive OrderBookStatus = "inactive"
)

// Defines values for OrderBookDetailStatus.
const (
	OrderBookDetailStatusActive   OrderBookDetailStatus = "active"
	OrderBookDetailStatusFrozen   OrderBookDetailStatus = "frozen"
	OrderBookDetailStatusInactive OrderBookDetailStatus = "inactive"
)

// Defines values for PositionFundingPositionSide.
const (
	PositionFundingPositionSideLong  PositionFundingPositionSide = "long"
	PositionFundingPositionSideShort PositionFundingPositionSide = "short"
)

// Defines values for TradeType.
const (
	TradeTypeDeleverage  TradeType = "deleverage"
	TradeTypeLiquidation TradeType = "liquidation"
	TradeTypeTrade       TradeType = "trade"
)

// Defines values for TransferHistoryItemType.
const (
	L2TransferInflow  TransferHistoryItemType = "L2TransferInflow"
	L2TransferOutflow TransferHistoryItemType = "L2TransferOutflow"
)

// Defines values for WithdrawHistoryItemStatus.
const (
	WithdrawHistoryItemStatusClaimable WithdrawHistoryItemStatus = "claimable"
	WithdrawHistoryItemStatusCompleted WithdrawHistoryItemStatus = "completed"
	WithdrawHistoryItemStatusFailed    WithdrawHistoryItemStatus = "failed"
	WithdrawHistoryItemStatusPending   WithdrawHistoryItemStatus = "pending"
	WithdrawHistoryItemStatusRefunded  WithdrawHistoryItemStatus = "refunded"
)

// Defines values for WithdrawHistoryItemType.
const (
	Fast   WithdrawHistoryItemType = "fast"
	Secure WithdrawHistoryItemType = "secure"
)

// Defines values for AccountParamsBy.
const (
	AccountParamsByIndex     AccountParamsBy = "index"
	AccountParamsByL1Address AccountParamsBy = "l1_address"
)

// Defines values for AccountMetadataParamsBy.
const (
	AccountMetadataParamsByIndex     AccountMetadataParamsBy = "index"
	AccountMetadataParamsByL1Address AccountMetadataParamsBy = "l1_address"
)

// Defines values for AccountTxsParamsBy.
const (
	AccountTxsParamsByAccountIndex AccountTxsParamsBy = "account_index"
)

// Defines values for BlockParamsBy.
const (
	Commitment BlockParamsBy = "commitment"
	Height     BlockParamsBy = "height"
)

// Defines values for BlockTxsParamsBy.
const (
	BlockTxsParamsByBlockCommitment BlockTxsParamsBy = "block_commitment"
	BlockTxsParamsByBlockHeight     BlockTxsParamsBy = "block_height"
)

// Defines values for BlocksParamsSort.
const (
	BlocksParamsSortAsc  BlocksParamsSort = "asc"
	BlocksParamsSortDesc BlocksParamsSort = "desc"
)

// Defines values for CandlesticksParamsResolution.
const (
	CandlesticksParamsResolutionN15m CandlesticksParamsResolution = "15m"
	CandlesticksParamsResolutionN1d  CandlesticksParamsResolution = "1d"
	CandlesticksParamsResolutionN1h  CandlesticksParamsResolution = "1h"
	CandlesticksParamsResolutionN1m  CandlesticksParamsResolution = "1m"
	CandlesticksParamsResolutionN4h  CandlesticksParamsResolution = "4h"
	CandlesticksParamsResolutionN5m  CandlesticksParamsResolution = "5m"
)

// Defines values for DepositHistoryParamsFilter.
const (
	DepositHistoryParamsFilterAll       DepositHistoryParamsFilter = "all"
	DepositHistoryParamsFilterClaimable DepositHistoryParamsFilter = "claimable"
	DepositHistoryParamsFilterPending   DepositHistoryParamsFilter = "pending"
)

// Defines values for ExportParamsType.
const (
	ExportParamsTypeFunding ExportParamsType = "funding"
	ExportParamsTypeTrade   ExportParamsType = "trade"
)

// Defines values for FundingsParamsResolution.
const (
	FundingsParamsResolutionN1d FundingsParamsResolution = "1d"
	FundingsParamsResolutionN1h FundingsParamsResolution = "1h"
)

// Defines values for PnlParamsBy.
const (
	Index PnlParamsBy = "index"
)

// Defines values for PnlParamsResolution.
const (
	N15m PnlParamsResolution = "15m"
	N1d  PnlParamsResolution = "1d"
	N1h  PnlParamsResolution = "1h"
	N1m  PnlParamsResolution = "1m"
	N4h  PnlParamsResolution = "4h"
	N5m  PnlParamsResolution = "5m"
)

// Defines values for PositionFundingParamsSide.
const (
	PositionFundingParamsSideAll   PositionFundingParamsSide = "all"
	PositionFundingParamsSideLong  PositionFundingParamsSide = "long"
	PositionFundingParamsSideShort PositionFundingParamsSide = "short"
)

// Defines values for PublicPoolsParamsFilter.
const (
	PublicPoolsParamsFilterAccountIndex PublicPoolsParamsFilter = "account_index"
	PublicPoolsParamsFilterAll          PublicPoolsParamsFilter = "all"
	PublicPoolsParamsFilterProtocol     PublicPoolsParamsFilter = "protocol"
	PublicPoolsParamsFilterUser         PublicPoolsParamsFilter = "user"
)

// Defines values for PublicPoolsMetadataParamsFilter.
const (
	PublicPoolsMetadataParamsFilterAccountIndex PublicPoolsMetadataParamsFilter = "account_index"
	PublicPoolsMetadataParamsFilterAll          PublicPoolsMetadataParamsFilter = "all"
	PublicPoolsMetadataParamsFilterProtocol     PublicPoolsMetadataParamsFilter = "protocol"
	PublicPoolsMetadataParamsFilterUser         PublicPoolsMetadataParamsFilter = "user"
)

// Defines values for TradesParamsSortBy.
const (
	TradesParamsSortByBlockHeight TradesParamsSortBy = "block_height"
	TradesParamsSortByTimestamp   TradesParamsSortBy = "timestamp"
	TradesParamsSortByTradeId     TradesParamsSortBy = "trade_id"
)

// Defines values for TradesParamsSortDir.
const (
	TradesParamsSortDirDesc TradesParamsSortDir = "desc"
)

// Defines values for TxParamsBy.
const (
	Hash          TxParamsBy = "hash"
	SequenceIndex TxParamsBy = "sequence_index"
)

// Defines values for WithdrawHistoryParamsFilter.
const (
	WithdrawHistoryParamsFilterAll       WithdrawHistoryParamsFilter = "all"
	WithdrawHistoryParamsFilterClaimable WithdrawHistoryParamsFilter = "claimable"
	WithdrawHistoryParamsFilterPending   WithdrawHistoryParamsFilter = "pending"
)

// Account defines model for Account.
type Account struct {
	AccountType             uint8   `json:"account_type"`
	AvailableBalance        string  `json:"available_balance"`
	CancelAllTime           int64   `json:"cancel_all_time"`
	Code                    int32   `json:"code"`
	Collateral              string  `json:"collateral"`
	Index                   int64   `json:"index"`
	L1Address               string  `json:"l1_address"`
	Message                 *string `json:"message,omitempty"`
	PendingOrderCount       int64   `json:"pending_order_count"`
	Status                  uint8   `json:"status"`
	TotalIsolatedOrderCount int64   `json:"total_isolated_order_count"`
	TotalOrderCount         int64   `json:"total_order_count"`
}

// AccountApiKeys defines model for AccountApiKeys.
type AccountApiKeys struct {
	ApiKeys []ApiKey `json:"api_keys"`
	Code    int32    `json:"code"`
	Message *string  `json:"message,omitempty"`
}

// AccountLimits defines model for AccountLimits.
type AccountLimits struct {
	Code             int32   `json:"code"`
	MaxLlpPercentage int32   `json:"max_llp_percentage"`
	Message          *string `json:"message,omitempty"`
	UserTier         string  `json:"user_tier"`
}

// AccountMetadata defines model for AccountMetadata.
type AccountMetadata struct {
	AccountIndex int64 `json:"account_index"`

	// CanInvite  Remove After FE uses L1 meta endpoint
	CanInvite   bool   `json:"can_invite"`
	Description string `json:"description"`
	Name        string `json:"name"`

	// ReferralPointsPercentage  Remove After FE uses L1 meta endpoint
	ReferralPointsPercentage string `json:"referral_points_percentage"`
}

// AccountMetadatas defines model for AccountMetadatas.
type AccountMetadatas struct {
	AccountMetadatas []AccountMetadata `json:"account_metadatas"`
	Code             int32             `json:"code"`
	Message          *string           `json:"message,omitempty"`
}

// AccountPnL defines model for AccountPnL.
type AccountPnL struct {
	Code       int32      `json:"code"`
	Message    *string    `json:"message,omitempty"`
	Pnl        []PnLEntry `json:"pnl"`
	Resolution string     `json:"resolution"`
}

// AccountPosition defines model for AccountPosition.
type AccountPosition struct {
	AllocatedMargin        string  `json:"allocated_margin"`
	AvgEntryPrice          string  `json:"avg_entry_price"`
	InitialMarginFraction  string  `json:"initial_margin_fraction"`
	LiquidationPrice       string  `json:"liquidation_price"`
	MarginMode             int32   `json:"margin_mode"`
	MarketId               uint8   `json:"market_id"`
	OpenOrderCount         int64   `json:"open_order_count"`
	PendingOrderCount      int64   `json:"pending_order_count"`
	Position               string  `json:"position"`
	PositionTiedOrderCount int64   `json:"position_tied_order_count"`
	PositionValue          string  `json:"position_value"`
	RealizedPnl            string  `json:"realized_pnl"`
	Sign                   int32   `json:"sign"`
	Symbol                 string  `json:"symbol"`
	TotalFundingPaidOut    *string `json:"total_funding_paid_out,omitempty"`
	UnrealizedPnl          string  `json:"unrealized_pnl"`
}

// Announcement defines model for Announcement.
type Announcement struct {
	Content   string `json:"content"`
	CreatedAt int64  `json:"created_at"`
	Title     string `json:"title"`
}

// Announcements defines model for Announcements.
type Announcements struct {
	Announcements []Announcement `json:"announcements"`
	Code          int32          `json:"code"`
	Message       *string        `json:"message,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	AccountIndex int64  `json:"account_index"`
	ApiKeyIndex  uint8  `json:"api_key_index"`
	Nonce        int64  `json:"nonce"`
	PublicKey    string `json:"public_key"`
}

// Block defines model for Block.
type Block struct {
	Commitment                      string `json:"commitment"`
	CommittedAt                     int64  `json:"committed_at"`
	CommittedTxHash                 string `json:"committed_tx_hash"`
	Height                          int64  `json:"height"`
	OnChainL2Operations             int32  `json:"on_chain_l2_operations"`
	PendingOnChainOperationsPubData string `json:"pending_on_chain_operations_pub_data"`
	PriorityOperations              int32  `json:"priority_operations"`
	Size                            int    `json:"size"`
	StateRoot                       string `json:"state_root"`
	Status                          int64  `json:"status"`
	Txs                             []Tx   `json:"txs"`
	VerifiedAt                      int64  `json:"verified_at"`
	VerifiedTxHash                  string `json:"verified_tx_hash"`
}

// Blocks defines model for Blocks.
type Blocks struct {
	Blocks  []Block `json:"blocks"`
	Code    int32   `json:"code"`
	Message *string `json:"message,omitempty"`
	Total   int64   `json:"total"`
}

// Candlestick defines model for Candlestick.
type Candlestick struct {
	Close       float64 `json:"close"`
	High        float64 `json:"high"`
	LastTradeId int64   `json:"last_trade_id"`
	Low         float64 `json:"low"`
	Open        float64 `json:"open"`
	Timestamp   int64   `json:"timestamp"`
	Volume0     float64 `json:"volume0"`
	Volume1     float64 `json:"volume1"`
}

// Candlesticks defines model for Candlesticks.
type Candlesticks struct {
	Candlesticks []Candlestick `json:"candlesticks"`
	Code         int32         `json:"code"`
	Message      *string       `json:"message,omitempty"`
	Resolution   string        `json:"resolution"`
}

// CurrentHeight defines model for CurrentHeight.
type CurrentHeight struct {
	Code    int32   `json:"code"`
	Height  int64   `json:"height"`
	Message *string `json:"message,omitempty"`
}

// DailyReturn defines model for DailyReturn.
type DailyReturn struct {
	DailyReturn float64 `json:"daily_return"`
	Timestamp   int64   `json:"timestamp"`
}

// DepositHistory defines model for DepositHistory.
type DepositHistory struct {
	Code     int32                `json:"code"`
	Cursor   string               `json:"cursor"`
	Deposits []DepositHistoryItem `json:"deposits"`
	Message  *string              `json:"message,omitempty"`
}

// DepositHistoryItem defines model for DepositHistoryItem.
type DepositHistoryItem struct {
	Amount    string                   `json:"amount"`
	Id        string                   `json:"id"`
	L1TxHash  string                   `json:"l1_tx_hash"`
	Status    DepositHistoryItemStatus `json:"status"`
	Timestamp int64                    `json:"timestamp"`
}

// DepositHistoryItemStatus defines model for DepositHistoryItem.Status.
type DepositHistoryItemStatus string

// DetailedAccount defines model for DetailedAccount.
type DetailedAccount struct {
	AccountIndex     int64  `json:"account_index"`
	AccountType      uint8  `json:"account_type"`
	AvailableBalance string `json:"available_balance"`

	// CanInvite  Remove After FE uses L1 meta endpoint
	CanInvite         bool              `json:"can_invite"`
	CancelAllTime     int64             `json:"cancel_all_time"`
	Code              int32             `json:"code"`
	Collateral        string            `json:"collateral"`
	CrossAssetValue   string            `json:"cross_asset_value"`
	Description       string            `json:"description"`
	Index             int64             `json:"index"`
	L1Address         string            `json:"l1_address"`
	Message           *string           `json:"message,omitempty"`
	Name              string            `json:"name"`
	PendingOrderCount int64             `json:"pending_order_count"`
	PoolInfo          PublicPoolInfo    `json:"pool_info"`
	Positions         []AccountPosition `json:"positions"`

	// ReferralPointsPercentage  Remove After FE uses L1 meta endpoint
	ReferralPointsPercentage string            `json:"referral_points_percentage"`
	Shares                   []PublicPoolShare `json:"shares"`
	Status                   uint8             `json:"status"`
	TotalAssetValue          string            `json:"total_asset_value"`
	TotalIsolatedOrderCount  int64             `json:"total_isolated_order_count"`
	TotalOrderCount          int64             `json:"total_order_count"`
}

// DetailedAccounts defines model for DetailedAccounts.
type DetailedAccounts struct {
	Accounts []DetailedAccount `json:"accounts"`
	Code     int32             `json:"code"`
	Message  *string           `json:"message,omitempty"`
	Total    int64             `json:"total"`
}

// EnrichedTx defines model for EnrichedTx.
type EnrichedTx struct {
	AccountIndex     int64   `json:"account_index"`
	BlockHeight      int64   `json:"block_height"`
	Code             int32   `json:"code"`
	CommittedAt      int64   `json:"committed_at"`
	EventInfo        string  `json:"event_info"`
	ExecutedAt       int64   `json:"executed_at"`
	ExpireAt         int64   `json:"expire_at"`
	Hash             string  `json:"hash"`
	Info             string  `json:"info"`
	L1Address        string  `json:"l1_address"`
	Message          *string `json:"message,omitempty"`
	Nonce            int64   `json:"nonce"`
	ParentHash       string  `json:"parent_hash"`
	QueuedAt         int64   `json:"queued_at"`
	SequenceIndex    int64   `json:"sequence_index"`
	Status           int64   `json:"status"`
	TransactionIndex int64   `json:"transaction_index"`
	Type             uint8   `json:"type"`
	VerifiedAt       int64   `json:"verified_at"`
}

// ExchangeStats defines model for ExchangeStats.
type ExchangeStats struct {
	Code             int32            `json:"code"`
	DailyTradesCount int64            `json:"daily_trades_count"`
	DailyUsdVolume   float64          `json:"daily_usd_volume"`
	Message          *string          `json:"message,omitempty"`
	OrderBookStats   []OrderBookStats `json:"order_book_stats"`
	Total            int64            `json:"total"`
}

// ExportData defines model for ExportData.
type ExportData struct {
	Code    int32   `json:"code"`
	DataUrl string  `json:"data_url"`
	Message *string `json:"message,omitempty"`
}

// Funding defines model for Funding.
type Funding struct {
	Direction string `json:"direction"`
	Rate      string `json:"rate"`
	Timestamp int64  `json:"timestamp"`
	Value     string `json:"value"`
}

// FundingRate defines model for FundingRate.
type FundingRate struct {
	Exchange FundingRateExchange `json:"exchange"`
	MarketId uint8               `json:"market_id"`
	Rate     float64             `json:"rate"`
	Symbol   string              `json:"symbol"`
}

// FundingRateExchange defines model for FundingRate.Exchange.
type FundingRateExchange string

// FundingRates defines model for FundingRates.
type FundingRates struct {
	Code         int32         `json:"code"`
	FundingRates []FundingRate `json:"funding_rates"`
	Message      *string       `json:"message,omitempty"`
}

// Fundings defines model for Fundings.
type Fundings struct {
	Code       int32     `json:"code"`
	Fundings   []Funding `json:"fundings"`
	Message    *string   `json:"message,omitempty"`
	Resolution string    `json:"resolution"`
}

// L1Metadata defines model for L1Metadata.
type L1Metadata struct {
	CanInvite                bool   `json:"can_invite"`
	L1Address                string `json:"l1_address"`
	ReferralPointsPercentage string `json:"referral_points_percentage"`
}

// LiqTrade defines model for LiqTrade.
type LiqTrade struct {
	MakerFee string `json:"maker_fee"`
	Price    string `json:"price"`
	Size     string `json:"size"`
	TakerFee string `json:"taker_fee"`
}

// Liquidation defines model for Liquidation.
type Liquidation struct {
	ExecutedAt int64           `json:"executed_at"`
	Id         int64           `json:"id"`
	Info       LiquidationInfo `json:"info"`
	MarketId   uint8           `json:"market_id"`
	Trade      LiqTrade        `json:"trade"`
	Type       LiquidationType `json:"type"`
}

// LiquidationType defines model for Liquidation.Type.
type LiquidationType string

// LiquidationInfo defines model for LiquidationInfo.
type LiquidationInfo struct {
	MarkPrices     map[string]float64 `json:"mark_prices"`
	Positions      []AccountPosition  `json:"positions"`
	RiskInfoAfter  RiskInfo           `json:"risk_info_after"`
	RiskInfoBefore RiskInfo           `json:"risk_info_before"`
}

// LiquidationInfos defines model for LiquidationInfos.
type LiquidationInfos struct {
	Code         int32         `json:"code"`
	Liquidations []Liquidation `json:"liquidations"`
	Message      *string       `json:"message,omitempty"`
	NextCursor   *string       `json:"next_cursor,omitempty"`
}

// NextNonce defines model for NextNonce.
type NextNonce struct {
	Code    int32   `json:"code"`
	Message *string `json:"message,omitempty"`
	Nonce   int64   `json:"nonce"`
}

// Order defines model for Order.
type Order struct {
	BasePrice           int32  `json:"base_price"`
	BaseSize            int64  `json:"base_size"`
	BlockHeight         int64  `json:"block_height"`
	ClientOrderId       string `json:"client_order_id"`
	ClientOrderIndex    int64  `json:"client_order_index"`
	FilledBaseAmount    string `json:"filled_base_amount"`
	FilledQuoteAmount   string `json:"filled_quote_amount"`
	InitialBaseAmount   string `json:"initial_base_amount"`
	IsAsk               bool   `json:"is_ask"`
	MarketIndex         uint8  `json:"market_index"`
	Nonce               int64  `json:"nonce"`
	OrderExpiry         int64  `json:"order_expiry"`
	OrderId             string `json:"order_id"`
	OrderIndex          int64  `json:"order_index"`
	OwnerAccountIndex   int64  `json:"owner_account_index"`
	ParentOrderId       string `json:"parent_order_id"`
	ParentOrderIndex    int64  `json:"parent_order_index"`
	Price               string `json:"price"`
	ReduceOnly          bool   `json:"reduce_only"`
	RemainingBaseAmount string `json:"remaining_base_amount"`

	// Side  TODO: remove this
	Side              string             `json:"side"`
	Status            OrderStatus        `json:"status"`
	TimeInForce       OrderTimeInForce   `json:"time_in_force"`
	Timestamp         int64              `json:"timestamp"`
	ToCancelOrderId0  string             `json:"to_cancel_order_id_0"`
	ToTriggerOrderId0 string             `json:"to_trigger_order_id_0"`
	ToTriggerOrderId1 string             `json:"to_trigger_order_id_1"`
	TriggerPrice      string             `json:"trigger_price"`
	TriggerStatus     OrderTriggerStatus `json:"trigger_status"`
	TriggerTime       int64              `json:"trigger_time"`
	Type              OrderType          `json:"type"`
}

// OrderStatus defines model for Order.Status.
type OrderStatus string

// OrderTimeInForce defines model for Order.TimeInForce.
type OrderTimeInForce string

// OrderTriggerStatus defines model for Order.TriggerStatus.
type OrderTriggerStatus string

// OrderType defines model for Order.Type.
type OrderType string

// OrderBook defines model for OrderBook.
type OrderBook struct {
	LiquidationFee         string          `json:"liquidation_fee"`
	MakerFee               string          `json:"maker_fee"`
	MarketId               uint8           `json:"market_id"`
	MinBaseAmount          string          `json:"min_base_amount"`
	MinQuoteAmount         string          `json:"min_quote_amount"`
	Status                 OrderBookStatus `json:"status"`
	SupportedPriceDecimals uint8           `json:"supported_price_decimals"`
	SupportedQuoteDecimals uint8           `json:"supported_quote_decimals"`
	SupportedSizeDecimals  uint8           `json:"supported_size_decimals"`
	Symbol                 string          `json:"symbol"`
	TakerFee               string          `json:"taker_fee"`
}

// OrderBookStatus defines model for OrderBook.Status.
type OrderBookStatus string

// OrderBookDetail defines model for OrderBookDetail.
type OrderBookDetail struct {
	CloseoutMarginFraction       int                   `json:"closeout_margin_fraction"`
	DailyBaseTokenVolume         float64               `json:"daily_base_token_volume"`
	DailyChart                   map[string]float64    `json:"daily_chart"`
	DailyPriceChange             float64               `json:"daily_price_change"`
	DailyPriceHigh               float64               `json:"daily_price_high"`
	DailyPriceLow                float64               `json:"daily_price_low"`
	DailyQuoteTokenVolume        float64               `json:"daily_quote_token_volume"`
	DailyTradesCount             int64                 `json:"daily_trades_count"`
	DefaultInitialMarginFraction int                   `json:"default_initial_margin_fraction"`
	LastTradePrice               float64               `json:"last_trade_price"`
	LiquidationFee               string                `json:"liquidation_fee"`
	MaintenanceMarginFraction    int                   `json:"maintenance_margin_fraction"`
	MakerFee                     string                `json:"maker_fee"`
	MarketId                     uint8                 `json:"market_id"`
	MinBaseAmount                string                `json:"min_base_amount"`
	MinInitialMarginFraction     int                   `json:"min_initial_margin_fraction"`
	MinQuoteAmount               string                `json:"min_quote_amount"`
	OpenInterest                 float64               `json:"open_interest"`
	PriceDecimals                uint8                 `json:"price_decimals"`
	QuoteMultiplier              int64                 `json:"quote_multiplier"`
	SizeDecimals                 uint8                 `json:"size_decimals"`
	Status                       OrderBookDetailStatus `json:"status"`
	SupportedPriceDecimals       uint8                 `json:"supported_price_decimals"`
	SupportedQuoteDecimals       uint8                 `json:"supported_quote_decimals"`
	SupportedSizeDecimals        uint8                 `json:"supported_size_decimals"`
	Symbol                       string                `json:"symbol"`
	TakerFee                     string                `json:"taker_fee"`
}

// OrderBookDetailStatus defines model for OrderBookDetail.Status.
type OrderBookDetailStatus string

// OrderBookDetails defines model for OrderBookDetails.
type OrderBookDetails struct {
	Code             int32             `json:"code"`
	Message          *string           `json:"message,omitempty"`
	OrderBookDetails []OrderBookDetail `json:"order_book_details"`
}

// OrderBookOrders defines model for OrderBookOrders.
type OrderBookOrders struct {
	Asks      []SimpleOrder `json:"asks"`
	Bids      []SimpleOrder `json:"bids"`
	Code      int32         `json:"code"`
	Message   *string       `json:"message,omitempty"`
	TotalAsks int64         `json:"total_asks"`
	TotalBids int64         `json:"total_bids"`
}

// OrderBookStats defines model for OrderBookStats.
type OrderBookStats struct {
	DailyBaseTokenVolume  float64 `json:"daily_base_token_volume"`
	DailyPriceChange      float64 `json:"daily_price_change"`
	DailyQuoteTokenVolume float64 `json:"daily_quote_token_volume"`
	DailyTradesCount      int64   `json:"daily_trades_count"`
	LastTradePrice        float64 `json:"last_trade_price"`
	Symbol                string  `json:"symbol"`
}

// OrderBooks defines model for OrderBooks.
type OrderBooks struct {
	Code       int32       `json:"code"`
	Message    *string     `json:"message,omitempty"`
	OrderBooks []OrderBook `json:"order_books"`
}

// Orders defines model for Orders.
type Orders struct {
	Code       int32   `json:"code"`
	Message    *string `json:"message,omitempty"`
	NextCursor *string `json:"next_cursor,omitempty"`
	Orders     []Order `json:"orders"`
}

// PnLEntry defines model for PnLEntry.
type PnLEntry struct {
	Inflow          float64 `json:"inflow"`
	Outflow         float64 `json:"outflow"`
	PoolInflow      float64 `json:"pool_inflow"`
	PoolOutflow     float64 `json:"pool_outflow"`
	PoolPnl         float64 `json:"pool_pnl"`
	PoolTotalShares float64 `json:"pool_total_shares"`
	Timestamp       int64   `json:"timestamp"`
	TradePnl        float64 `json:"trade_pnl"`
}

// PositionFunding defines model for PositionFunding.
type PositionFunding struct {
	Change       string                      `json:"change"`
	FundingId    int64                       `json:"funding_id"`
	MarketId     uint8                       `json:"market_id"`
	PositionSide PositionFundingPositionSide `json:"position_side"`
	PositionSize string                      `json:"position_size"`
	Rate         string                      `json:"rate"`
	Timestamp    int64                       `json:"timestamp"`
}

// PositionFundingPositionSide defines model for PositionFunding.PositionSide.
type PositionFundingPositionSide string

// PositionFundings defines model for PositionFundings.
type PositionFundings struct {
	Code             int32             `json:"code"`
	Message          *string           `json:"message,omitempty"`
	NextCursor       *string           `json:"next_cursor,omitempty"`
	PositionFundings []PositionFunding `json:"position_fundings"`
}

// PublicPool defines model for PublicPool.
type PublicPool struct {
	AccountIndex     int64            `json:"account_index"`
	AccountShare     *PublicPoolShare `json:"account_share,omitempty"`
	AccountType      uint8            `json:"account_type"`
	AvailableBalance string           `json:"available_balance"`

	// CanInvite  Remove After FE uses L1 meta endpoint
	CanInvite         bool           `json:"can_invite"`
	CancelAllTime     int64          `json:"cancel_all_time"`
	Code              int32          `json:"code"`
	Collateral        string         `json:"collateral"`
	CrossAssetValue   string         `json:"cross_asset_value"`
	Description       string         `json:"description"`
	Index             int64          `json:"index"`
	L1Address         string         `json:"l1_address"`
	Message           *string        `json:"message,omitempty"`
	Name              string         `json:"name"`
	PendingOrderCount int64          `json:"pending_order_count"`
	PoolInfo          PublicPoolInfo `json:"pool_info"`

	// ReferralPointsPercentage  Remove After FE uses L1 meta endpoint
	ReferralPointsPercentage string `json:"referral_points_percentage"`
	Status                   uint8  `json:"status"`
	TotalAssetValue          string `json:"total_asset_value"`
	TotalIsolatedOrderCount  int64  `json:"total_isolated_order_count"`
	TotalOrderCount          int64  `json:"total_order_count"`
}

// PublicPoolInfo defines model for PublicPoolInfo.
type PublicPoolInfo struct {
	AnnualPercentageYield float64       `json:"annual_percentage_yield"`
	DailyReturns          []DailyReturn `json:"daily_returns"`
	MinOperatorShareRate  string        `json:"min_operator_share_rate"`
	OperatorFee           string        `json:"operator_fee"`
	OperatorShares        int64         `json:"operator_shares"`
	SharePrices           []SharePrice  `json:"share_prices"`
	Status                uint8         `json:"status"`
	TotalShares           int64         `json:"total_shares"`
}

// PublicPoolMetadata defines model for PublicPoolMetadata.
type PublicPoolMetadata struct {
	AccountIndex          int64            `json:"account_index"`
	AccountShare          *PublicPoolShare `json:"account_share,omitempty"`
	AccountType           uint8            `json:"account_type"`
	AnnualPercentageYield float64          `json:"annual_percentage_yield"`
	Code                  int32            `json:"code"`
	L1Address             string           `json:"l1_address"`
	Message               *string          `json:"message,omitempty"`
	Name                  string           `json:"name"`
	OperatorFee           string           `json:"operator_fee"`
	Status                uint8            `json:"status"`
	TotalAssetValue       string           `json:"total_asset_value"`
	TotalShares           int64            `json:"total_shares"`
}

// PublicPoolShare defines model for PublicPoolShare.
type PublicPoolShare struct {
	EntryUsdc       string `json:"entry_usdc"`
	PublicPoolIndex int64  `json:"public_pool_index"`
	SharesAmount    int64  `json:"shares_amount"`
}

// PublicPools defines model for PublicPools.
type PublicPools struct {
	Code        int32        `json:"code"`
	Message     *string      `json:"message,omitempty"`
	PublicPools []PublicPool `json:"public_pools"`
	Total       int64        `json:"total"`
}

// ReferralPointEntry defines model for ReferralPointEntry.
type ReferralPointEntry struct {
	L1Address             string `json:"l1_address"`
	RewardPointMultiplier string `json:"reward_point_multiplier"`
	TotalPoints           int64  `json:"total_points"`
	TotalRewardPoints     int64  `json:"total_reward_points"`
	WeekPoints            int64  `json:"week_points"`
	WeekRewardPoints      int64  `json:"week_reward_points"`
}

// ReferralPoints defines model for ReferralPoints.
type ReferralPoints struct {
	Referrals                        []ReferralPointEntry `json:"referrals"`
	RewardPointMultiplier            string               `json:"reward_point_multiplier"`
	UserLastWeekPoints               int64                `json:"user_last_week_points"`
	UserLastWeekReferralRewardPoints int64                `json:"user_last_week_referral_reward_points"`
	UserTotalPoints                  int64                `json:"user_total_points"`
	UserTotalReferralRewardPoints    int64                `json:"user_total_referral_reward_points"`
}

// ReqAckNotif defines model for ReqAckNotif.
type ReqAckNotif struct {
	AccountIndex int64 `json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth    *string `json:"auth,omitempty"`
	NotifId string  `json:"notif_id"`
}

// ReqChangeAccountTier defines model for ReqChangeAccountTier.
type ReqChangeAccountTier struct {
	AccountIndex int64 `json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth    *string `json:"auth,omitempty"`
	NewTier string  `json:"new_tier"`
}

// ReqSendTx defines model for ReqSendTx.
type ReqSendTx struct {
	PriceProtection *bool  `json:"price_protection,omitempty"`
	TxInfo          string `json:"tx_info"`
	TxType          uint8  `json:"tx_type"`
}

// ReqSendTxBatch defines model for ReqSendTxBatch.
type ReqSendTxBatch struct {
	TxInfos string `json:"tx_infos"`
	TxTypes string `json:"tx_types"`
}

// RespChangeAccountTier defines model for RespChangeAccountTier.
type RespChangeAccountTier struct {
	Code    int32   `json:"code"`
	Message *string `json:"message,omitempty"`
}

// RespGetFastBridgeInfo defines model for RespGetFastBridgeInfo.
type RespGetFastBridgeInfo struct {
	Code            int32   `json:"code"`
	FastBridgeLimit string  `json:"fast_bridge_limit"`
	Message         *string `json:"message,omitempty"`
}

// RespPublicPoolsMetadata defines model for RespPublicPoolsMetadata.
type RespPublicPoolsMetadata struct {
	Code        int32                `json:"code"`
	Message     *string              `json:"message,omitempty"`
	PublicPools []PublicPoolMetadata `json:"public_pools"`
}

// RespSendTx defines model for RespSendTx.
type RespSendTx struct {
	Code                     int32   `json:"code"`
	Message                  *string `json:"message,omitempty"`
	PredictedExecutionTimeMs int64   `json:"predicted_execution_time_ms"`
	TxHash                   string  `json:"tx_hash"`
}

// RespSendTxBatch defines model for RespSendTxBatch.
type RespSendTxBatch struct {
	Code                     int32    `json:"code"`
	Message                  *string  `json:"message,omitempty"`
	PredictedExecutionTimeMs int64    `json:"predicted_execution_time_ms"`
	TxHash                   []string `json:"tx_hash"`
}

// RespWithdrawalDelay defines model for RespWithdrawalDelay.
type RespWithdrawalDelay struct {
	Seconds int64 `json:"seconds"`
}

// ResultCode defines model for ResultCode.
type ResultCode struct {
	Code    int32   `json:"code"`
	Message *string `json:"message,omitempty"`
}

// RiskInfo defines model for RiskInfo.
type RiskInfo struct {
	CrossRiskParameters    RiskParameters   `json:"cross_risk_parameters"`
	IsolatedRiskParameters []RiskParameters `json:"isolated_risk_parameters"`
}

// RiskParameters defines model for RiskParameters.
type RiskParameters struct {
	CloseOutMarginReq    string `json:"close_out_margin_req"`
	Collateral           string `json:"collateral"`
	InitialMarginReq     string `json:"initial_margin_req"`
	MaintenanceMarginReq string `json:"maintenance_margin_req"`
	MarketId             uint8  `json:"market_id"`
	TotalAccountValue    string `json:"total_account_value"`
}

// SharePrice defines model for SharePrice.
type SharePrice struct {
	SharePrice float64 `json:"share_price"`
	Timestamp  int64   `json:"timestamp"`
}

// SimpleOrder defines model for SimpleOrder.
type SimpleOrder struct {
	InitialBaseAmount   string `json:"initial_base_amount"`
	OrderExpiry         int64  `json:"order_expiry"`
	OrderId             string `json:"order_id"`
	OrderIndex          int64  `json:"order_index"`
	OwnerAccountIndex   int64  `json:"owner_account_index"`
	Price               string `json:"price"`
	RemainingBaseAmount string `json:"remaining_base_amount"`
}

// Status defines model for Status.
type Status struct {
	NetworkId int32 `json:"network_id"`
	Status    int32 `json:"status"`
	Timestamp int64 `json:"timestamp"`
}

// SubAccounts defines model for SubAccounts.
type SubAccounts struct {
	Code        int32     `json:"code"`
	L1Address   string    `json:"l1_address"`
	Message     *string   `json:"message,omitempty"`
	SubAccounts []Account `json:"sub_accounts"`
}

// Trade defines model for Trade.
type Trade struct {
	AskAccountId                     int64     `json:"ask_account_id"`
	AskId                            int64     `json:"ask_id"`
	BidAccountId                     int64     `json:"bid_account_id"`
	BidId                            int64     `json:"bid_id"`
	BlockHeight                      int64     `json:"block_height"`
	IsMakerAsk                       bool      `json:"is_maker_ask"`
	MakerEntryQuoteBefore            string    `json:"maker_entry_quote_before"`
	MakerFee                         int32     `json:"maker_fee"`
	MakerInitialMarginFractionBefore int       `json:"maker_initial_margin_fraction_before"`
	MakerPositionSignChanged         bool      `json:"maker_position_sign_changed"`
	MakerPositionSizeBefore          string    `json:"maker_position_size_before"`
	MarketId                         uint8     `json:"market_id"`
	Price                            string    `json:"price"`
	Size                             string    `json:"size"`
	TakerEntryQuoteBefore            string    `json:"taker_entry_quote_before"`
	TakerFee                         int32     `json:"taker_fee"`
	TakerInitialMarginFractionBefore int       `json:"taker_initial_margin_fraction_before"`
	TakerPositionSignChanged         bool      `json:"taker_position_sign_changed"`
	TakerPositionSizeBefore          string    `json:"taker_position_size_before"`
	Timestamp                        int64     `json:"timestamp"`
	TradeId                          int64     `json:"trade_id"`
	TxHash                           string    `json:"tx_hash"`
	Type                             TradeType `json:"type"`
	UsdAmount                        string    `json:"usd_amount"`
}

// TradeType defines model for Trade.Type.
type TradeType string

// Trades defines model for Trades.
type Trades struct {
	Code       int32   `json:"code"`
	Message    *string `json:"message,omitempty"`
	NextCursor *string `json:"next_cursor,omitempty"`
	Trades     []Trade `json:"trades"`
}

// TransferFeeInfo defines model for TransferFeeInfo.
type TransferFeeInfo struct {
	Code            int32   `json:"code"`
	Message         *string `json:"message,omitempty"`
	TransferFeeUsdc int64   `json:"transfer_fee_usdc"`
}

// TransferHistory defines model for TransferHistory.
type TransferHistory struct {
	Code      int32                 `json:"code"`
	Cursor    string                `json:"cursor"`
	Message   *string               `json:"message,omitempty"`
	Transfers []TransferHistoryItem `json:"transfers"`
}

// TransferHistoryItem defines model for TransferHistoryItem.
type TransferHistoryItem struct {
	Amount           string                  `json:"amount"`
	FromAccountIndex int64                   `json:"from_account_index"`
	FromL1Address    string                  `json:"from_l1_address"`
	Id               string                  `json:"id"`
	Timestamp        int64                   `json:"timestamp"`
	ToAccountIndex   int64                   `json:"to_account_index"`
	ToL1Address      string                  `json:"to_l1_address"`
	TxHash           string                  `json:"tx_hash"`
	Type             TransferHistoryItemType `json:"type"`
}

// TransferHistoryItemType defines model for TransferHistoryItem.Type.
type TransferHistoryItemType string

// Tx defines model for Tx.
type Tx struct {
	AccountIndex     int64  `json:"account_index"`
	BlockHeight      int64  `json:"block_height"`
	EventInfo        string `json:"event_info"`
	ExecutedAt       int64  `json:"executed_at"`
	ExpireAt         int64  `json:"expire_at"`
	Hash             string `json:"hash"`
	Info             string `json:"info"`
	L1Address        string `json:"l1_address"`
	Nonce            int64  `json:"nonce"`
	ParentHash       string `json:"parent_hash"`
	QueuedAt         int64  `json:"queued_at"`
	SequenceIndex    int64  `json:"sequence_index"`
	Status           int64  `json:"status"`
	TransactionIndex int64  `json:"transaction_index"`
	Type             uint8  `json:"type"`
}

// Txs defines model for Txs.
type Txs struct {
	Code    int32   `json:"code"`
	Message *string `json:"message,omitempty"`
	Txs     []Tx    `json:"txs"`
}

// WithdrawHistory defines model for WithdrawHistory.
type WithdrawHistory struct {
	Code      int32                 `json:"code"`
	Cursor    string                `json:"cursor"`
	Message   *string               `json:"message,omitempty"`
	Withdraws []WithdrawHistoryItem `json:"withdraws"`
}

// WithdrawHistoryItem defines model for WithdrawHistoryItem.
type WithdrawHistoryItem struct {
	Amount    string                    `json:"amount"`
	Id        string                    `json:"id"`
	L1TxHash  string                    `json:"l1_tx_hash"`
	Status    WithdrawHistoryItemStatus `json:"status"`
	Timestamp int64                     `json:"timestamp"`
	Type      WithdrawHistoryItemType   `json:"type"`
}

// WithdrawHistoryItemStatus defines model for WithdrawHistoryItem.Status.
type WithdrawHistoryItemStatus string

// WithdrawHistoryItemType defines model for WithdrawHistoryItem.Type.
type WithdrawHistoryItemType string

// ZkLighterInfo defines model for ZkLighterInfo.
type ZkLighterInfo struct {
	ContractAddress string `json:"contract_address"`
}

// AccountParams defines parameters for Account.
type AccountParams struct {
	By    AccountParamsBy `form:"by" json:"by"`
	Value string          `form:"value" json:"value"`
}

// AccountParamsBy defines parameters for Account.
type AccountParamsBy string

// AccountActiveOrdersParams defines parameters for AccountActiveOrders.
type AccountActiveOrdersParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`
	MarketId     uint8 `form:"market_id" json:"market_id"`

	// Auth  made optional to support header auth clients
	Auth *string `form:"auth,omitempty" json:"auth,omitempty"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// AccountInactiveOrdersParams defines parameters for AccountInactiveOrders.
type AccountInactiveOrdersParams struct {
	// Auth  made optional to support header auth clients
	Auth              *string `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex      int64   `form:"account_index" json:"account_index"`
	MarketId          *uint8  `form:"market_id,omitempty" json:"market_id,omitempty"`
	AskFilter         *int8   `form:"ask_filter,omitempty" json:"ask_filter,omitempty"`
	BetweenTimestamps *string `form:"between_timestamps,omitempty" json:"between_timestamps,omitempty"`
	Cursor            *string `form:"cursor,omitempty" json:"cursor,omitempty"`
	Limit             int64   `form:"limit" json:"limit"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// AccountLimitsParams defines parameters for AccountLimits.
type AccountLimitsParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth *string `form:"auth,omitempty" json:"auth,omitempty"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// AccountMetadataParams defines parameters for AccountMetadata.
type AccountMetadataParams struct {
	By            AccountMetadataParamsBy `form:"by" json:"by"`
	Value         string                  `form:"value" json:"value"`
	Auth          *string                 `form:"auth,omitempty" json:"auth,omitempty"`
	Authorization *string                 `json:"authorization,omitempty"`
}

// AccountMetadataParamsBy defines parameters for AccountMetadata.
type AccountMetadataParamsBy string

// AccountTxsParams defines parameters for AccountTxs.
type AccountTxsParams struct {
	Index         *int64             `form:"index,omitempty" json:"index,omitempty"`
	Limit         int64              `form:"limit" json:"limit"`
	By            AccountTxsParamsBy `form:"by" json:"by"`
	Value         string             `form:"value" json:"value"`
	Types         *[]uint8           `form:"types,omitempty" json:"types,omitempty"`
	Auth          *string            `form:"auth,omitempty" json:"auth,omitempty"`
	Authorization *string            `json:"authorization,omitempty"`
}

// AccountTxsParamsBy defines parameters for AccountTxs.
type AccountTxsParamsBy string

// AccountsByL1AddressParams defines parameters for AccountsByL1Address.
type AccountsByL1AddressParams struct {
	L1Address string `form:"l1_address" json:"l1_address"`
}

// ApikeysParams defines parameters for Apikeys.
type ApikeysParams struct {
	AccountIndex int64  `form:"account_index" json:"account_index"`
	ApiKeyIndex  *uint8 `form:"api_key_index,omitempty" json:"api_key_index,omitempty"`
}

// BlockParams defines parameters for Block.
type BlockParams struct {
	By    BlockParamsBy `form:"by" json:"by"`
	Value string        `form:"value" json:"value"`
}

// BlockParamsBy defines parameters for Block.
type BlockParamsBy string

// BlockTxsParams defines parameters for BlockTxs.
type BlockTxsParams struct {
	By    BlockTxsParamsBy `form:"by" json:"by"`
	Value string           `form:"value" json:"value"`
}

// BlockTxsParamsBy defines parameters for BlockTxs.
type BlockTxsParamsBy string

// BlocksParams defines parameters for Blocks.
type BlocksParams struct {
	Index *int64            `form:"index,omitempty" json:"index,omitempty"`
	Limit int64             `form:"limit" json:"limit"`
	Sort  *BlocksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// BlocksParamsSort defines parameters for Blocks.
type BlocksParamsSort string

// CandlesticksParams defines parameters for Candlesticks.
type CandlesticksParams struct {
	MarketId          uint8                        `form:"market_id" json:"market_id"`
	Resolution        CandlesticksParamsResolution `form:"resolution" json:"resolution"`
	StartTimestamp    int64                        `form:"start_timestamp" json:"start_timestamp"`
	EndTimestamp      int64                        `form:"end_timestamp" json:"end_timestamp"`
	CountBack         int64                        `form:"count_back" json:"count_back"`
	SetTimestampToEnd *bool                        `form:"set_timestamp_to_end,omitempty" json:"set_timestamp_to_end,omitempty"`
}

// CandlesticksParamsResolution defines parameters for Candlesticks.
type CandlesticksParamsResolution string

// ChangeAccountTierParams defines parameters for ChangeAccountTier.
type ChangeAccountTierParams struct {
	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// DepositHistoryParams defines parameters for DepositHistory.
type DepositHistoryParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth      *string                     `form:"auth,omitempty" json:"auth,omitempty"`
	L1Address string                      `form:"l1_address" json:"l1_address"`
	Cursor    *string                     `form:"cursor,omitempty" json:"cursor,omitempty"`
	Filter    *DepositHistoryParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// DepositHistoryParamsFilter defines parameters for DepositHistory.
type DepositHistoryParamsFilter string

// ExportParams defines parameters for Export.
type ExportParams struct {
	Auth          *string          `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex  *int64           `form:"account_index,omitempty" json:"account_index,omitempty"`
	MarketId      *uint8           `form:"market_id,omitempty" json:"market_id,omitempty"`
	Type          ExportParamsType `form:"type" json:"type"`
	Authorization *string          `json:"authorization,omitempty"`
}

// ExportParamsType defines parameters for Export.
type ExportParamsType string

// FundingsParams defines parameters for Fundings.
type FundingsParams struct {
	MarketId       uint8                    `form:"market_id" json:"market_id"`
	Resolution     FundingsParamsResolution `form:"resolution" json:"resolution"`
	StartTimestamp int64                    `form:"start_timestamp" json:"start_timestamp"`
	EndTimestamp   int64                    `form:"end_timestamp" json:"end_timestamp"`
	CountBack      int64                    `form:"count_back" json:"count_back"`
}

// FundingsParamsResolution defines parameters for Fundings.
type FundingsParamsResolution string

// L1MetadataParams defines parameters for L1Metadata.
type L1MetadataParams struct {
	// Auth  made optional to support header auth clients
	Auth      *string `form:"auth,omitempty" json:"auth,omitempty"`
	L1Address string  `form:"l1_address" json:"l1_address"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// LiquidationsParams defines parameters for Liquidations.
type LiquidationsParams struct {
	// Auth  made optional to support header auth clients
	Auth         *string `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex int64   `form:"account_index" json:"account_index"`
	MarketId     *uint8  `form:"market_id,omitempty" json:"market_id,omitempty"`
	Cursor       *string `form:"cursor,omitempty" json:"cursor,omitempty"`
	Limit        int64   `form:"limit" json:"limit"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// NextNonceParams defines parameters for NextNonce.
type NextNonceParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`
	ApiKeyIndex  uint8 `form:"api_key_index" json:"api_key_index"`
}

// NotificationAckParams defines parameters for NotificationAck.
type NotificationAckParams struct {
	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// OrderBookDetailsParams defines parameters for OrderBookDetails.
type OrderBookDetailsParams struct {
	MarketId *uint8 `form:"market_id,omitempty" json:"market_id,omitempty"`
}

// OrderBookOrdersParams defines parameters for OrderBookOrders.
type OrderBookOrdersParams struct {
	MarketId uint8 `form:"market_id" json:"market_id"`
	Limit    int64 `form:"limit" json:"limit"`
}

// OrderBooksParams defines parameters for OrderBooks.
type OrderBooksParams struct {
	MarketId *uint8 `form:"market_id,omitempty" json:"market_id,omitempty"`
}

// PnlParams defines parameters for Pnl.
type PnlParams struct {
	Auth            *string             `form:"auth,omitempty" json:"auth,omitempty"`
	By              PnlParamsBy         `form:"by" json:"by"`
	Value           string              `form:"value" json:"value"`
	Resolution      PnlParamsResolution `form:"resolution" json:"resolution"`
	StartTimestamp  int64               `form:"start_timestamp" json:"start_timestamp"`
	EndTimestamp    int64               `form:"end_timestamp" json:"end_timestamp"`
	CountBack       int64               `form:"count_back" json:"count_back"`
	IgnoreTransfers *bool               `form:"ignore_transfers,omitempty" json:"ignore_transfers,omitempty"`
	Authorization   *string             `json:"authorization,omitempty"`
}

// PnlParamsBy defines parameters for Pnl.
type PnlParamsBy string

// PnlParamsResolution defines parameters for Pnl.
type PnlParamsResolution string

// PositionFundingParams defines parameters for PositionFunding.
type PositionFundingParams struct {
	Auth          *string                    `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex  int64                      `form:"account_index" json:"account_index"`
	MarketId      *uint8                     `form:"market_id,omitempty" json:"market_id,omitempty"`
	Cursor        *string                    `form:"cursor,omitempty" json:"cursor,omitempty"`
	Limit         int64                      `form:"limit" json:"limit"`
	Side          *PositionFundingParamsSide `form:"side,omitempty" json:"side,omitempty"`
	Authorization *string                    `json:"authorization,omitempty"`
}

// PositionFundingParamsSide defines parameters for PositionFunding.
type PositionFundingParamsSide string

// PublicPoolsParams defines parameters for PublicPools.
type PublicPoolsParams struct {
	Auth          *string                  `form:"auth,omitempty" json:"auth,omitempty"`
	Filter        *PublicPoolsParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Index         int64                    `form:"index" json:"index"`
	Limit         int64                    `form:"limit" json:"limit"`
	AccountIndex  *int64                   `form:"account_index,omitempty" json:"account_index,omitempty"`
	Authorization *string                  `json:"authorization,omitempty"`
}

// PublicPoolsParamsFilter defines parameters for PublicPools.
type PublicPoolsParamsFilter string

// PublicPoolsMetadataParams defines parameters for PublicPoolsMetadata.
type PublicPoolsMetadataParams struct {
	Auth          *string                          `form:"auth,omitempty" json:"auth,omitempty"`
	Filter        *PublicPoolsMetadataParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Index         int64                            `form:"index" json:"index"`
	Limit         int64                            `form:"limit" json:"limit"`
	AccountIndex  *int64                           `form:"account_index,omitempty" json:"account_index,omitempty"`
	Authorization *string                          `json:"authorization,omitempty"`
}

// PublicPoolsMetadataParamsFilter defines parameters for PublicPoolsMetadata.
type PublicPoolsMetadataParamsFilter string

// RecentTradesParams defines parameters for RecentTrades.
type RecentTradesParams struct {
	MarketId uint8 `form:"market_id" json:"market_id"`
	Limit    int64 `form:"limit" json:"limit"`
}

// ReferralPointsParams defines parameters for ReferralPoints.
type ReferralPointsParams struct {
	// Auth  made optional to support header auth clients
	Auth         *string `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex int64   `form:"account_index" json:"account_index"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// TradesParams defines parameters for Trades.
type TradesParams struct {
	Auth          *string              `form:"auth,omitempty" json:"auth,omitempty"`
	MarketId      *uint8               `form:"market_id,omitempty" json:"market_id,omitempty"`
	AccountIndex  *int64               `form:"account_index,omitempty" json:"account_index,omitempty"`
	OrderIndex    *int64               `form:"order_index,omitempty" json:"order_index,omitempty"`
	SortBy        TradesParamsSortBy   `form:"sort_by" json:"sort_by"`
	SortDir       *TradesParamsSortDir `form:"sort_dir,omitempty" json:"sort_dir,omitempty"`
	Cursor        *string              `form:"cursor,omitempty" json:"cursor,omitempty"`
	From          *int64               `form:"from,omitempty" json:"from,omitempty"`
	AskFilter     *int8                `form:"ask_filter,omitempty" json:"ask_filter,omitempty"`
	Limit         int64                `form:"limit" json:"limit"`
	Authorization *string              `json:"authorization,omitempty"`
}

// TradesParamsSortBy defines parameters for Trades.
type TradesParamsSortBy string

// TradesParamsSortDir defines parameters for Trades.
type TradesParamsSortDir string

// TransferHistoryParams defines parameters for TransferHistory.
type TransferHistoryParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth   *string `form:"auth,omitempty" json:"auth,omitempty"`
	Cursor *string `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// TransferFeeInfoParams defines parameters for TransferFeeInfo.
type TransferFeeInfoParams struct {
	Auth           *string `form:"auth,omitempty" json:"auth,omitempty"`
	AccountIndex   int64   `form:"account_index" json:"account_index"`
	ToAccountIndex *int64  `form:"to_account_index,omitempty" json:"to_account_index,omitempty"`
	Authorization  *string `json:"authorization,omitempty"`
}

// TxParams defines parameters for Tx.
type TxParams struct {
	By    TxParamsBy `form:"by" json:"by"`
	Value string     `form:"value" json:"value"`
}

// TxParamsBy defines parameters for Tx.
type TxParamsBy string

// TxFromL1TxHashParams defines parameters for TxFromL1TxHash.
type TxFromL1TxHashParams struct {
	Hash string `form:"hash" json:"hash"`
}

// TxsParams defines parameters for Txs.
type TxsParams struct {
	Index *int64 `form:"index,omitempty" json:"index,omitempty"`
	Limit int64  `form:"limit" json:"limit"`
}

// WithdrawHistoryParams defines parameters for WithdrawHistory.
type WithdrawHistoryParams struct {
	AccountIndex int64 `form:"account_index" json:"account_index"`

	// Auth  made optional to support header auth clients
	Auth   *string                      `form:"auth,omitempty" json:"auth,omitempty"`
	Cursor *string                      `form:"cursor,omitempty" json:"cursor,omitempty"`
	Filter *WithdrawHistoryParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Authorization  make required after integ is done
	Authorization *string `json:"authorization,omitempty"`
}

// WithdrawHistoryParamsFilter defines parameters for WithdrawHistory.
type WithdrawHistoryParamsFilter string

// ChangeAccountTierMultipartRequestBody defines body for ChangeAccountTier for multipart/form-data ContentType.
type ChangeAccountTierMultipartRequestBody = ReqChangeAccountTier

// NotificationAckMultipartRequestBody defines body for NotificationAck for multipart/form-data ContentType.
type NotificationAckMultipartRequestBody = ReqAckNotif

// SendTxMultipartRequestBody defines body for SendTx for multipart/form-data ContentType.
type SendTxMultipartRequestBody = ReqSendTx

// SendTxBatchMultipartRequestBody defines body for SendTxBatch for multipart/form-data ContentType.
type SendTxBatchMultipartRequestBody = ReqSendTxBatch

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Status request
	Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Account request
	Account(ctx context.Context, params *AccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountActiveOrders request
	AccountActiveOrders(ctx context.Context, params *AccountActiveOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountInactiveOrders request
	AccountInactiveOrders(ctx context.Context, params *AccountInactiveOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountLimits request
	AccountLimits(ctx context.Context, params *AccountLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountMetadata request
	AccountMetadata(ctx context.Context, params *AccountMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountTxs request
	AccountTxs(ctx context.Context, params *AccountTxsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AccountsByL1Address request
	AccountsByL1Address(ctx context.Context, params *AccountsByL1AddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Announcement request
	Announcement(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Apikeys request
	Apikeys(ctx context.Context, params *ApikeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Block request
	Block(ctx context.Context, params *BlockParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockTxs request
	BlockTxs(ctx context.Context, params *BlockTxsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Blocks request
	Blocks(ctx context.Context, params *BlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Candlesticks request
	Candlesticks(ctx context.Context, params *CandlesticksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeAccountTierWithBody request with any body
	ChangeAccountTierWithBody(ctx context.Context, params *ChangeAccountTierParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentHeight request
	CurrentHeight(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DepositHistory request
	DepositHistory(ctx context.Context, params *DepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeStats request
	ExchangeStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Export request
	Export(ctx context.Context, params *ExportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FastbridgeInfo request
	FastbridgeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FundingRates request
	FundingRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Fundings request
	Fundings(ctx context.Context, params *FundingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// L1Metadata request
	L1Metadata(ctx context.Context, params *L1MetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Liquidations request
	Liquidations(ctx context.Context, params *LiquidationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NextNonce request
	NextNonce(ctx context.Context, params *NextNonceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NotificationAckWithBody request with any body
	NotificationAckWithBody(ctx context.Context, params *NotificationAckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrderBookDetails request
	OrderBookDetails(ctx context.Context, params *OrderBookDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrderBookOrders request
	OrderBookOrders(ctx context.Context, params *OrderBookOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrderBooks request
	OrderBooks(ctx context.Context, params *OrderBooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pnl request
	Pnl(ctx context.Context, params *PnlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PositionFunding request
	PositionFunding(ctx context.Context, params *PositionFundingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicPools request
	PublicPools(ctx context.Context, params *PublicPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublicPoolsMetadata request
	PublicPoolsMetadata(ctx context.Context, params *PublicPoolsMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecentTrades request
	RecentTrades(ctx context.Context, params *RecentTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReferralPoints request
	ReferralPoints(ctx context.Context, params *ReferralPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendTxWithBody request with any body
	SendTxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendTxBatchWithBody request with any body
	SendTxBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Trades request
	Trades(ctx context.Context, params *TradesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferHistory request
	TransferHistory(ctx context.Context, params *TransferHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferFeeInfo request
	TransferFeeInfo(ctx context.Context, params *TransferFeeInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Tx request
	Tx(ctx context.Context, params *TxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TxFromL1TxHash request
	TxFromL1TxHash(ctx context.Context, params *TxFromL1TxHashParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Txs request
	Txs(ctx context.Context, params *TxsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawHistory request
	WithdrawHistory(ctx context.Context, params *WithdrawHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawalDelay request
	WithdrawalDelay(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Info request
	Info(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Status(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Account(ctx context.Context, params *AccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountActiveOrders(ctx context.Context, params *AccountActiveOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountActiveOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountInactiveOrders(ctx context.Context, params *AccountInactiveOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountInactiveOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountLimits(ctx context.Context, params *AccountLimitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountLimitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountMetadata(ctx context.Context, params *AccountMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountTxs(ctx context.Context, params *AccountTxsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountTxsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AccountsByL1Address(ctx context.Context, params *AccountsByL1AddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAccountsByL1AddressRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Announcement(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAnnouncementRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Apikeys(ctx context.Context, params *ApikeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApikeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Block(ctx context.Context, params *BlockParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockTxs(ctx context.Context, params *BlockTxsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockTxsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Blocks(ctx context.Context, params *BlocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlocksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Candlesticks(ctx context.Context, params *CandlesticksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCandlesticksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeAccountTierWithBody(ctx context.Context, params *ChangeAccountTierParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeAccountTierRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentHeight(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentHeightRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepositHistory(ctx context.Context, params *DepositHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepositHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Export(ctx context.Context, params *ExportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FastbridgeInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFastbridgeInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FundingRates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFundingRatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Fundings(ctx context.Context, params *FundingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFundingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) L1Metadata(ctx context.Context, params *L1MetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewL1MetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Liquidations(ctx context.Context, params *LiquidationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiquidationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NextNonce(ctx context.Context, params *NextNonceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNextNonceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NotificationAckWithBody(ctx context.Context, params *NotificationAckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNotificationAckRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrderBookDetails(ctx context.Context, params *OrderBookDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderBookDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrderBookOrders(ctx context.Context, params *OrderBookOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderBookOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrderBooks(ctx context.Context, params *OrderBooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrderBooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pnl(ctx context.Context, params *PnlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPnlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PositionFunding(ctx context.Context, params *PositionFundingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPositionFundingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicPools(ctx context.Context, params *PublicPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicPoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublicPoolsMetadata(ctx context.Context, params *PublicPoolsMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublicPoolsMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecentTrades(ctx context.Context, params *RecentTradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecentTradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReferralPoints(ctx context.Context, params *ReferralPointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReferralPointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendTxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendTxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendTxBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendTxBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Trades(ctx context.Context, params *TradesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTradesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferHistory(ctx context.Context, params *TransferHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferFeeInfo(ctx context.Context, params *TransferFeeInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferFeeInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tx(ctx context.Context, params *TxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TxFromL1TxHash(ctx context.Context, params *TxFromL1TxHashParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTxFromL1TxHashRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Txs(ctx context.Context, params *TxsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTxsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawHistory(ctx context.Context, params *WithdrawHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawHistoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawalDelay(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawalDelayRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Info(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewStatusRequest generates requests for Status
func NewStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountRequest generates requests for Account
func NewAccountRequest(server string, params *AccountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAccountActiveOrdersRequest generates requests for AccountActiveOrders
func NewAccountActiveOrdersRequest(server string, params *AccountActiveOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountActiveOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, params.MarketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewAccountInactiveOrdersRequest generates requests for AccountInactiveOrders
func NewAccountInactiveOrdersRequest(server string, params *AccountInactiveOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountInactiveOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AskFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ask_filter", runtime.ParamLocationQuery, *params.AskFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BetweenTimestamps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "between_timestamps", runtime.ParamLocationQuery, *params.BetweenTimestamps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewAccountLimitsRequest generates requests for AccountLimits
func NewAccountLimitsRequest(server string, params *AccountLimitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountLimits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewAccountMetadataRequest generates requests for AccountMetadata
func NewAccountMetadataRequest(server string, params *AccountMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountMetadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewAccountTxsRequest generates requests for AccountTxs
func NewAccountTxsRequest(server string, params *AccountTxsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountTxs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewAccountsByL1AddressRequest generates requests for AccountsByL1Address
func NewAccountsByL1AddressRequest(server string, params *AccountsByL1AddressParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/accountsByL1Address")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "l1_address", runtime.ParamLocationQuery, params.L1Address); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAnnouncementRequest generates requests for Announcement
func NewAnnouncementRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/announcement")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewApikeysRequest generates requests for Apikeys
func NewApikeysRequest(server string, params *ApikeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/apikeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ApiKeyIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_key_index", runtime.ParamLocationQuery, *params.ApiKeyIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockRequest generates requests for Block
func NewBlockRequest(server string, params *BlockParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/block")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockTxsRequest generates requests for BlockTxs
func NewBlockTxsRequest(server string, params *BlockTxsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/blockTxs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlocksRequest generates requests for Blocks
func NewBlocksRequest(server string, params *BlocksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCandlesticksRequest generates requests for Candlesticks
func NewCandlesticksRequest(server string, params *CandlesticksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/candlesticks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, params.MarketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_timestamp", runtime.ParamLocationQuery, params.StartTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_timestamp", runtime.ParamLocationQuery, params.EndTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count_back", runtime.ParamLocationQuery, params.CountBack); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SetTimestampToEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "set_timestamp_to_end", runtime.ParamLocationQuery, *params.SetTimestampToEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeAccountTierRequestWithBody generates requests for ChangeAccountTier with any type of body
func NewChangeAccountTierRequestWithBody(server string, params *ChangeAccountTierParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/changeAccountTier")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewCurrentHeightRequest generates requests for CurrentHeight
func NewCurrentHeightRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/currentHeight")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDepositHistoryRequest generates requests for DepositHistory
func NewDepositHistoryRequest(server string, params *DepositHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/deposit/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "l1_address", runtime.ParamLocationQuery, params.L1Address); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewExchangeStatsRequest generates requests for ExchangeStats
func NewExchangeStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/exchangeStats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportRequest generates requests for Export
func NewExportRequest(server string, params *ExportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, *params.AccountIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewFastbridgeInfoRequest generates requests for FastbridgeInfo
func NewFastbridgeInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/fastbridge/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFundingRatesRequest generates requests for FundingRates
func NewFundingRatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/funding-rates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFundingsRequest generates requests for Fundings
func NewFundingsRequest(server string, params *FundingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/fundings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, params.MarketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_timestamp", runtime.ParamLocationQuery, params.StartTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_timestamp", runtime.ParamLocationQuery, params.EndTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count_back", runtime.ParamLocationQuery, params.CountBack); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewL1MetadataRequest generates requests for L1Metadata
func NewL1MetadataRequest(server string, params *L1MetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/l1Metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "l1_address", runtime.ParamLocationQuery, params.L1Address); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewLiquidationsRequest generates requests for Liquidations
func NewLiquidationsRequest(server string, params *LiquidationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/liquidations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewNextNonceRequest generates requests for NextNonce
func NewNextNonceRequest(server string, params *NextNonceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/nextNonce")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "api_key_index", runtime.ParamLocationQuery, params.ApiKeyIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNotificationAckRequestWithBody generates requests for NotificationAck with any type of body
func NewNotificationAckRequestWithBody(server string, params *NotificationAckParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/notification/ack")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewOrderBookDetailsRequest generates requests for OrderBookDetails
func NewOrderBookDetailsRequest(server string, params *OrderBookDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orderBookDetails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderBookOrdersRequest generates requests for OrderBookOrders
func NewOrderBookOrdersRequest(server string, params *OrderBookOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orderBookOrders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, params.MarketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrderBooksRequest generates requests for OrderBooks
func NewOrderBooksRequest(server string, params *OrderBooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/orderBooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPnlRequest generates requests for Pnl
func NewPnlRequest(server string, params *PnlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/pnl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_timestamp", runtime.ParamLocationQuery, params.StartTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_timestamp", runtime.ParamLocationQuery, params.EndTimestamp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count_back", runtime.ParamLocationQuery, params.CountBack); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IgnoreTransfers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignore_transfers", runtime.ParamLocationQuery, *params.IgnoreTransfers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewPositionFundingRequest generates requests for PositionFunding
func NewPositionFundingRequest(server string, params *PositionFundingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/positionFunding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Side != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "side", runtime.ParamLocationQuery, *params.Side); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewPublicPoolsRequest generates requests for PublicPools
func NewPublicPoolsRequest(server string, params *PublicPoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/publicPools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, params.Index); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AccountIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, *params.AccountIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewPublicPoolsMetadataRequest generates requests for PublicPoolsMetadata
func NewPublicPoolsMetadataRequest(server string, params *PublicPoolsMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/publicPoolsMetadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, params.Index); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.AccountIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, *params.AccountIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewRecentTradesRequest generates requests for RecentTrades
func NewRecentTradesRequest(server string, params *RecentTradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/recentTrades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, params.MarketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReferralPointsRequest generates requests for ReferralPoints
func NewReferralPointsRequest(server string, params *ReferralPointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/referral/points")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewSendTxRequestWithBody generates requests for SendTx with any type of body
func NewSendTxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sendTx")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendTxBatchRequestWithBody generates requests for SendTxBatch with any type of body
func NewSendTxBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/sendTxBatch")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTradesRequest generates requests for Trades
func NewTradesRequest(server string, params *TradesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/trades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MarketId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "market_id", runtime.ParamLocationQuery, *params.MarketId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AccountIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, *params.AccountIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_index", runtime.ParamLocationQuery, *params.OrderIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_by", runtime.ParamLocationQuery, params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_dir", runtime.ParamLocationQuery, *params.SortDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AskFilter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ask_filter", runtime.ParamLocationQuery, *params.AskFilter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewTransferHistoryRequest generates requests for TransferHistory
func NewTransferHistoryRequest(server string, params *TransferHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transfer/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewTransferFeeInfoRequest generates requests for TransferFeeInfo
func NewTransferFeeInfoRequest(server string, params *TransferFeeInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/transferFeeInfo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ToAccountIndex != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_account_index", runtime.ParamLocationQuery, *params.ToAccountIndex); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewTxRequest generates requests for Tx
func NewTxRequest(server string, params *TxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/tx")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "by", runtime.ParamLocationQuery, params.By); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "value", runtime.ParamLocationQuery, params.Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTxFromL1TxHashRequest generates requests for TxFromL1TxHash
func NewTxFromL1TxHashRequest(server string, params *TxFromL1TxHashParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/txFromL1TxHash")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, params.Hash); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTxsRequest generates requests for Txs
func NewTxsRequest(server string, params *TxsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/txs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWithdrawHistoryRequest generates requests for WithdrawHistory
func NewWithdrawHistoryRequest(server string, params *WithdrawHistoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/withdraw/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "account_index", runtime.ParamLocationQuery, params.AccountIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Auth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "auth", runtime.ParamLocationQuery, *params.Auth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Authorization != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization", runtime.ParamLocationHeader, *params.Authorization)
			if err != nil {
				return nil, err
			}

			req.Header.Set("authorization", headerParam0)
		}

	}

	return req, nil
}

// NewWithdrawalDelayRequest generates requests for WithdrawalDelay
func NewWithdrawalDelayRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v1/withdrawalDelay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInfoRequest generates requests for Info
func NewInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// StatusWithResponse request
	StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error)

	// AccountWithResponse request
	AccountWithResponse(ctx context.Context, params *AccountParams, reqEditors ...RequestEditorFn) (*AccountResponse, error)

	// AccountActiveOrdersWithResponse request
	AccountActiveOrdersWithResponse(ctx context.Context, params *AccountActiveOrdersParams, reqEditors ...RequestEditorFn) (*AccountActiveOrdersResponse, error)

	// AccountInactiveOrdersWithResponse request
	AccountInactiveOrdersWithResponse(ctx context.Context, params *AccountInactiveOrdersParams, reqEditors ...RequestEditorFn) (*AccountInactiveOrdersResponse, error)

	// AccountLimitsWithResponse request
	AccountLimitsWithResponse(ctx context.Context, params *AccountLimitsParams, reqEditors ...RequestEditorFn) (*AccountLimitsResponse, error)

	// AccountMetadataWithResponse request
	AccountMetadataWithResponse(ctx context.Context, params *AccountMetadataParams, reqEditors ...RequestEditorFn) (*AccountMetadataResponse, error)

	// AccountTxsWithResponse request
	AccountTxsWithResponse(ctx context.Context, params *AccountTxsParams, reqEditors ...RequestEditorFn) (*AccountTxsResponse, error)

	// AccountsByL1AddressWithResponse request
	AccountsByL1AddressWithResponse(ctx context.Context, params *AccountsByL1AddressParams, reqEditors ...RequestEditorFn) (*AccountsByL1AddressResponse, error)

	// AnnouncementWithResponse request
	AnnouncementWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AnnouncementResponse, error)

	// ApikeysWithResponse request
	ApikeysWithResponse(ctx context.Context, params *ApikeysParams, reqEditors ...RequestEditorFn) (*ApikeysResponse, error)

	// BlockWithResponse request
	BlockWithResponse(ctx context.Context, params *BlockParams, reqEditors ...RequestEditorFn) (*BlockResponse, error)

	// BlockTxsWithResponse request
	BlockTxsWithResponse(ctx context.Context, params *BlockTxsParams, reqEditors ...RequestEditorFn) (*BlockTxsResponse, error)

	// BlocksWithResponse request
	BlocksWithResponse(ctx context.Context, params *BlocksParams, reqEditors ...RequestEditorFn) (*BlocksResponse, error)

	// CandlesticksWithResponse request
	CandlesticksWithResponse(ctx context.Context, params *CandlesticksParams, reqEditors ...RequestEditorFn) (*CandlesticksResponse, error)

	// ChangeAccountTierWithBodyWithResponse request with any body
	ChangeAccountTierWithBodyWithResponse(ctx context.Context, params *ChangeAccountTierParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeAccountTierResponse, error)

	// CurrentHeightWithResponse request
	CurrentHeightWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentHeightResponse, error)

	// DepositHistoryWithResponse request
	DepositHistoryWithResponse(ctx context.Context, params *DepositHistoryParams, reqEditors ...RequestEditorFn) (*DepositHistoryResponse, error)

	// ExchangeStatsWithResponse request
	ExchangeStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeStatsResponse, error)

	// ExportWithResponse request
	ExportWithResponse(ctx context.Context, params *ExportParams, reqEditors ...RequestEditorFn) (*ExportResponse, error)

	// FastbridgeInfoWithResponse request
	FastbridgeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FastbridgeInfoResponse, error)

	// FundingRatesWithResponse request
	FundingRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FundingRatesResponse, error)

	// FundingsWithResponse request
	FundingsWithResponse(ctx context.Context, params *FundingsParams, reqEditors ...RequestEditorFn) (*FundingsResponse, error)

	// L1MetadataWithResponse request
	L1MetadataWithResponse(ctx context.Context, params *L1MetadataParams, reqEditors ...RequestEditorFn) (*L1MetadataResponse, error)

	// LiquidationsWithResponse request
	LiquidationsWithResponse(ctx context.Context, params *LiquidationsParams, reqEditors ...RequestEditorFn) (*LiquidationsResponse, error)

	// NextNonceWithResponse request
	NextNonceWithResponse(ctx context.Context, params *NextNonceParams, reqEditors ...RequestEditorFn) (*NextNonceResponse, error)

	// NotificationAckWithBodyWithResponse request with any body
	NotificationAckWithBodyWithResponse(ctx context.Context, params *NotificationAckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationAckResponse, error)

	// OrderBookDetailsWithResponse request
	OrderBookDetailsWithResponse(ctx context.Context, params *OrderBookDetailsParams, reqEditors ...RequestEditorFn) (*OrderBookDetailsResponse, error)

	// OrderBookOrdersWithResponse request
	OrderBookOrdersWithResponse(ctx context.Context, params *OrderBookOrdersParams, reqEditors ...RequestEditorFn) (*OrderBookOrdersResponse, error)

	// OrderBooksWithResponse request
	OrderBooksWithResponse(ctx context.Context, params *OrderBooksParams, reqEditors ...RequestEditorFn) (*OrderBooksResponse, error)

	// PnlWithResponse request
	PnlWithResponse(ctx context.Context, params *PnlParams, reqEditors ...RequestEditorFn) (*PnlResponse, error)

	// PositionFundingWithResponse request
	PositionFundingWithResponse(ctx context.Context, params *PositionFundingParams, reqEditors ...RequestEditorFn) (*PositionFundingResponse, error)

	// PublicPoolsWithResponse request
	PublicPoolsWithResponse(ctx context.Context, params *PublicPoolsParams, reqEditors ...RequestEditorFn) (*PublicPoolsResponse, error)

	// PublicPoolsMetadataWithResponse request
	PublicPoolsMetadataWithResponse(ctx context.Context, params *PublicPoolsMetadataParams, reqEditors ...RequestEditorFn) (*PublicPoolsMetadataResponse, error)

	// RecentTradesWithResponse request
	RecentTradesWithResponse(ctx context.Context, params *RecentTradesParams, reqEditors ...RequestEditorFn) (*RecentTradesResponse, error)

	// ReferralPointsWithResponse request
	ReferralPointsWithResponse(ctx context.Context, params *ReferralPointsParams, reqEditors ...RequestEditorFn) (*ReferralPointsResponse, error)

	// SendTxWithBodyWithResponse request with any body
	SendTxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTxResponse, error)

	// SendTxBatchWithBodyWithResponse request with any body
	SendTxBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTxBatchResponse, error)

	// TradesWithResponse request
	TradesWithResponse(ctx context.Context, params *TradesParams, reqEditors ...RequestEditorFn) (*TradesResponse, error)

	// TransferHistoryWithResponse request
	TransferHistoryWithResponse(ctx context.Context, params *TransferHistoryParams, reqEditors ...RequestEditorFn) (*TransferHistoryResponse, error)

	// TransferFeeInfoWithResponse request
	TransferFeeInfoWithResponse(ctx context.Context, params *TransferFeeInfoParams, reqEditors ...RequestEditorFn) (*TransferFeeInfoResponse, error)

	// TxWithResponse request
	TxWithResponse(ctx context.Context, params *TxParams, reqEditors ...RequestEditorFn) (*TxResponse, error)

	// TxFromL1TxHashWithResponse request
	TxFromL1TxHashWithResponse(ctx context.Context, params *TxFromL1TxHashParams, reqEditors ...RequestEditorFn) (*TxFromL1TxHashResponse, error)

	// TxsWithResponse request
	TxsWithResponse(ctx context.Context, params *TxsParams, reqEditors ...RequestEditorFn) (*TxsResponse, error)

	// WithdrawHistoryWithResponse request
	WithdrawHistoryWithResponse(ctx context.Context, params *WithdrawHistoryParams, reqEditors ...RequestEditorFn) (*WithdrawHistoryResponse, error)

	// WithdrawalDelayWithResponse request
	WithdrawalDelayWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WithdrawalDelayResponse, error)

	// InfoWithResponse request
	InfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoResponse, error)
}

type StatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Status
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r StatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DetailedAccounts
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountActiveOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Orders
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountActiveOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountActiveOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountInactiveOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Orders
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountInactiveOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountInactiveOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountLimits
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountMetadatas
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountTxsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Txs
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountTxsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountTxsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AccountsByL1AddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubAccounts
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AccountsByL1AddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AccountsByL1AddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AnnouncementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Announcements
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r AnnouncementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AnnouncementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApikeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountApiKeys
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r ApikeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApikeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blocks
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r BlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockTxsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Txs
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r BlockTxsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockTxsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blocks
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r BlocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CandlesticksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Candlesticks
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r CandlesticksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CandlesticksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeAccountTierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespChangeAccountTier
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r ChangeAccountTierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeAccountTierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentHeightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrentHeight
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r CurrentHeightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentHeightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DepositHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DepositHistory
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r DepositHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DepositHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExchangeStats
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r ExchangeStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportData
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r ExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FastbridgeInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespGetFastBridgeInfo
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r FastbridgeInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FastbridgeInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FundingRatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FundingRates
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r FundingRatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FundingRatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FundingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Fundings
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r FundingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FundingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type L1MetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *L1Metadata
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r L1MetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r L1MetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LiquidationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LiquidationInfos
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r LiquidationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiquidationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NextNonceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NextNonce
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r NextNonceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NextNonceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NotificationAckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResultCode
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r NotificationAckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NotificationAckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderBookDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderBookDetails
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r OrderBookDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderBookDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderBookOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderBookOrders
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r OrderBookOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderBookOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrderBooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderBooks
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r OrderBooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrderBooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PnlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountPnL
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r PnlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PnlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PositionFundingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PositionFundings
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r PositionFundingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PositionFundingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicPoolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicPools
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r PublicPoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicPoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublicPoolsMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespPublicPoolsMetadata
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r PublicPoolsMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublicPoolsMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecentTradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Trades
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r RecentTradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecentTradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReferralPointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReferralPoints
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r ReferralPointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReferralPointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendTxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespSendTx
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r SendTxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendTxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendTxBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespSendTxBatch
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r SendTxBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendTxBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TradesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Trades
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TradesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TradesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferHistory
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TransferHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferFeeInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransferFeeInfo
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TransferFeeInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferFeeInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedTx
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TxFromL1TxHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnrichedTx
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TxFromL1TxHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TxFromL1TxHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TxsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Txs
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r TxsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TxsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WithdrawHistory
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r WithdrawHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawalDelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RespWithdrawalDelay
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r WithdrawalDelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawalDelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZkLighterInfo
	JSON400      *ResultCode
}

// Status returns HTTPResponse.Status
func (r InfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// StatusWithResponse request returning *StatusResponse
func (c *ClientWithResponses) StatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusResponse, error) {
	rsp, err := c.Status(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusResponse(rsp)
}

// AccountWithResponse request returning *AccountResponse
func (c *ClientWithResponses) AccountWithResponse(ctx context.Context, params *AccountParams, reqEditors ...RequestEditorFn) (*AccountResponse, error) {
	rsp, err := c.Account(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountResponse(rsp)
}

// AccountActiveOrdersWithResponse request returning *AccountActiveOrdersResponse
func (c *ClientWithResponses) AccountActiveOrdersWithResponse(ctx context.Context, params *AccountActiveOrdersParams, reqEditors ...RequestEditorFn) (*AccountActiveOrdersResponse, error) {
	rsp, err := c.AccountActiveOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountActiveOrdersResponse(rsp)
}

// AccountInactiveOrdersWithResponse request returning *AccountInactiveOrdersResponse
func (c *ClientWithResponses) AccountInactiveOrdersWithResponse(ctx context.Context, params *AccountInactiveOrdersParams, reqEditors ...RequestEditorFn) (*AccountInactiveOrdersResponse, error) {
	rsp, err := c.AccountInactiveOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountInactiveOrdersResponse(rsp)
}

// AccountLimitsWithResponse request returning *AccountLimitsResponse
func (c *ClientWithResponses) AccountLimitsWithResponse(ctx context.Context, params *AccountLimitsParams, reqEditors ...RequestEditorFn) (*AccountLimitsResponse, error) {
	rsp, err := c.AccountLimits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountLimitsResponse(rsp)
}

// AccountMetadataWithResponse request returning *AccountMetadataResponse
func (c *ClientWithResponses) AccountMetadataWithResponse(ctx context.Context, params *AccountMetadataParams, reqEditors ...RequestEditorFn) (*AccountMetadataResponse, error) {
	rsp, err := c.AccountMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountMetadataResponse(rsp)
}

// AccountTxsWithResponse request returning *AccountTxsResponse
func (c *ClientWithResponses) AccountTxsWithResponse(ctx context.Context, params *AccountTxsParams, reqEditors ...RequestEditorFn) (*AccountTxsResponse, error) {
	rsp, err := c.AccountTxs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountTxsResponse(rsp)
}

// AccountsByL1AddressWithResponse request returning *AccountsByL1AddressResponse
func (c *ClientWithResponses) AccountsByL1AddressWithResponse(ctx context.Context, params *AccountsByL1AddressParams, reqEditors ...RequestEditorFn) (*AccountsByL1AddressResponse, error) {
	rsp, err := c.AccountsByL1Address(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAccountsByL1AddressResponse(rsp)
}

// AnnouncementWithResponse request returning *AnnouncementResponse
func (c *ClientWithResponses) AnnouncementWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AnnouncementResponse, error) {
	rsp, err := c.Announcement(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAnnouncementResponse(rsp)
}

// ApikeysWithResponse request returning *ApikeysResponse
func (c *ClientWithResponses) ApikeysWithResponse(ctx context.Context, params *ApikeysParams, reqEditors ...RequestEditorFn) (*ApikeysResponse, error) {
	rsp, err := c.Apikeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApikeysResponse(rsp)
}

// BlockWithResponse request returning *BlockResponse
func (c *ClientWithResponses) BlockWithResponse(ctx context.Context, params *BlockParams, reqEditors ...RequestEditorFn) (*BlockResponse, error) {
	rsp, err := c.Block(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockResponse(rsp)
}

// BlockTxsWithResponse request returning *BlockTxsResponse
func (c *ClientWithResponses) BlockTxsWithResponse(ctx context.Context, params *BlockTxsParams, reqEditors ...RequestEditorFn) (*BlockTxsResponse, error) {
	rsp, err := c.BlockTxs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlockTxsResponse(rsp)
}

// BlocksWithResponse request returning *BlocksResponse
func (c *ClientWithResponses) BlocksWithResponse(ctx context.Context, params *BlocksParams, reqEditors ...RequestEditorFn) (*BlocksResponse, error) {
	rsp, err := c.Blocks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBlocksResponse(rsp)
}

// CandlesticksWithResponse request returning *CandlesticksResponse
func (c *ClientWithResponses) CandlesticksWithResponse(ctx context.Context, params *CandlesticksParams, reqEditors ...RequestEditorFn) (*CandlesticksResponse, error) {
	rsp, err := c.Candlesticks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCandlesticksResponse(rsp)
}

// ChangeAccountTierWithBodyWithResponse request with arbitrary body returning *ChangeAccountTierResponse
func (c *ClientWithResponses) ChangeAccountTierWithBodyWithResponse(ctx context.Context, params *ChangeAccountTierParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeAccountTierResponse, error) {
	rsp, err := c.ChangeAccountTierWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeAccountTierResponse(rsp)
}

// CurrentHeightWithResponse request returning *CurrentHeightResponse
func (c *ClientWithResponses) CurrentHeightWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CurrentHeightResponse, error) {
	rsp, err := c.CurrentHeight(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentHeightResponse(rsp)
}

// DepositHistoryWithResponse request returning *DepositHistoryResponse
func (c *ClientWithResponses) DepositHistoryWithResponse(ctx context.Context, params *DepositHistoryParams, reqEditors ...RequestEditorFn) (*DepositHistoryResponse, error) {
	rsp, err := c.DepositHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepositHistoryResponse(rsp)
}

// ExchangeStatsWithResponse request returning *ExchangeStatsResponse
func (c *ClientWithResponses) ExchangeStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExchangeStatsResponse, error) {
	rsp, err := c.ExchangeStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeStatsResponse(rsp)
}

// ExportWithResponse request returning *ExportResponse
func (c *ClientWithResponses) ExportWithResponse(ctx context.Context, params *ExportParams, reqEditors ...RequestEditorFn) (*ExportResponse, error) {
	rsp, err := c.Export(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportResponse(rsp)
}

// FastbridgeInfoWithResponse request returning *FastbridgeInfoResponse
func (c *ClientWithResponses) FastbridgeInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FastbridgeInfoResponse, error) {
	rsp, err := c.FastbridgeInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFastbridgeInfoResponse(rsp)
}

// FundingRatesWithResponse request returning *FundingRatesResponse
func (c *ClientWithResponses) FundingRatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FundingRatesResponse, error) {
	rsp, err := c.FundingRates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFundingRatesResponse(rsp)
}

// FundingsWithResponse request returning *FundingsResponse
func (c *ClientWithResponses) FundingsWithResponse(ctx context.Context, params *FundingsParams, reqEditors ...RequestEditorFn) (*FundingsResponse, error) {
	rsp, err := c.Fundings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFundingsResponse(rsp)
}

// L1MetadataWithResponse request returning *L1MetadataResponse
func (c *ClientWithResponses) L1MetadataWithResponse(ctx context.Context, params *L1MetadataParams, reqEditors ...RequestEditorFn) (*L1MetadataResponse, error) {
	rsp, err := c.L1Metadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseL1MetadataResponse(rsp)
}

// LiquidationsWithResponse request returning *LiquidationsResponse
func (c *ClientWithResponses) LiquidationsWithResponse(ctx context.Context, params *LiquidationsParams, reqEditors ...RequestEditorFn) (*LiquidationsResponse, error) {
	rsp, err := c.Liquidations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiquidationsResponse(rsp)
}

// NextNonceWithResponse request returning *NextNonceResponse
func (c *ClientWithResponses) NextNonceWithResponse(ctx context.Context, params *NextNonceParams, reqEditors ...RequestEditorFn) (*NextNonceResponse, error) {
	rsp, err := c.NextNonce(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNextNonceResponse(rsp)
}

// NotificationAckWithBodyWithResponse request with arbitrary body returning *NotificationAckResponse
func (c *ClientWithResponses) NotificationAckWithBodyWithResponse(ctx context.Context, params *NotificationAckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NotificationAckResponse, error) {
	rsp, err := c.NotificationAckWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNotificationAckResponse(rsp)
}

// OrderBookDetailsWithResponse request returning *OrderBookDetailsResponse
func (c *ClientWithResponses) OrderBookDetailsWithResponse(ctx context.Context, params *OrderBookDetailsParams, reqEditors ...RequestEditorFn) (*OrderBookDetailsResponse, error) {
	rsp, err := c.OrderBookDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderBookDetailsResponse(rsp)
}

// OrderBookOrdersWithResponse request returning *OrderBookOrdersResponse
func (c *ClientWithResponses) OrderBookOrdersWithResponse(ctx context.Context, params *OrderBookOrdersParams, reqEditors ...RequestEditorFn) (*OrderBookOrdersResponse, error) {
	rsp, err := c.OrderBookOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderBookOrdersResponse(rsp)
}

// OrderBooksWithResponse request returning *OrderBooksResponse
func (c *ClientWithResponses) OrderBooksWithResponse(ctx context.Context, params *OrderBooksParams, reqEditors ...RequestEditorFn) (*OrderBooksResponse, error) {
	rsp, err := c.OrderBooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrderBooksResponse(rsp)
}

// PnlWithResponse request returning *PnlResponse
func (c *ClientWithResponses) PnlWithResponse(ctx context.Context, params *PnlParams, reqEditors ...RequestEditorFn) (*PnlResponse, error) {
	rsp, err := c.Pnl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePnlResponse(rsp)
}

// PositionFundingWithResponse request returning *PositionFundingResponse
func (c *ClientWithResponses) PositionFundingWithResponse(ctx context.Context, params *PositionFundingParams, reqEditors ...RequestEditorFn) (*PositionFundingResponse, error) {
	rsp, err := c.PositionFunding(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePositionFundingResponse(rsp)
}

// PublicPoolsWithResponse request returning *PublicPoolsResponse
func (c *ClientWithResponses) PublicPoolsWithResponse(ctx context.Context, params *PublicPoolsParams, reqEditors ...RequestEditorFn) (*PublicPoolsResponse, error) {
	rsp, err := c.PublicPools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicPoolsResponse(rsp)
}

// PublicPoolsMetadataWithResponse request returning *PublicPoolsMetadataResponse
func (c *ClientWithResponses) PublicPoolsMetadataWithResponse(ctx context.Context, params *PublicPoolsMetadataParams, reqEditors ...RequestEditorFn) (*PublicPoolsMetadataResponse, error) {
	rsp, err := c.PublicPoolsMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublicPoolsMetadataResponse(rsp)
}

// RecentTradesWithResponse request returning *RecentTradesResponse
func (c *ClientWithResponses) RecentTradesWithResponse(ctx context.Context, params *RecentTradesParams, reqEditors ...RequestEditorFn) (*RecentTradesResponse, error) {
	rsp, err := c.RecentTrades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecentTradesResponse(rsp)
}

// ReferralPointsWithResponse request returning *ReferralPointsResponse
func (c *ClientWithResponses) ReferralPointsWithResponse(ctx context.Context, params *ReferralPointsParams, reqEditors ...RequestEditorFn) (*ReferralPointsResponse, error) {
	rsp, err := c.ReferralPoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReferralPointsResponse(rsp)
}

// SendTxWithBodyWithResponse request with arbitrary body returning *SendTxResponse
func (c *ClientWithResponses) SendTxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTxResponse, error) {
	rsp, err := c.SendTxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendTxResponse(rsp)
}

// SendTxBatchWithBodyWithResponse request with arbitrary body returning *SendTxBatchResponse
func (c *ClientWithResponses) SendTxBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendTxBatchResponse, error) {
	rsp, err := c.SendTxBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSendTxBatchResponse(rsp)
}

// TradesWithResponse request returning *TradesResponse
func (c *ClientWithResponses) TradesWithResponse(ctx context.Context, params *TradesParams, reqEditors ...RequestEditorFn) (*TradesResponse, error) {
	rsp, err := c.Trades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTradesResponse(rsp)
}

// TransferHistoryWithResponse request returning *TransferHistoryResponse
func (c *ClientWithResponses) TransferHistoryWithResponse(ctx context.Context, params *TransferHistoryParams, reqEditors ...RequestEditorFn) (*TransferHistoryResponse, error) {
	rsp, err := c.TransferHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferHistoryResponse(rsp)
}

// TransferFeeInfoWithResponse request returning *TransferFeeInfoResponse
func (c *ClientWithResponses) TransferFeeInfoWithResponse(ctx context.Context, params *TransferFeeInfoParams, reqEditors ...RequestEditorFn) (*TransferFeeInfoResponse, error) {
	rsp, err := c.TransferFeeInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferFeeInfoResponse(rsp)
}

// TxWithResponse request returning *TxResponse
func (c *ClientWithResponses) TxWithResponse(ctx context.Context, params *TxParams, reqEditors ...RequestEditorFn) (*TxResponse, error) {
	rsp, err := c.Tx(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTxResponse(rsp)
}

// TxFromL1TxHashWithResponse request returning *TxFromL1TxHashResponse
func (c *ClientWithResponses) TxFromL1TxHashWithResponse(ctx context.Context, params *TxFromL1TxHashParams, reqEditors ...RequestEditorFn) (*TxFromL1TxHashResponse, error) {
	rsp, err := c.TxFromL1TxHash(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTxFromL1TxHashResponse(rsp)
}

// TxsWithResponse request returning *TxsResponse
func (c *ClientWithResponses) TxsWithResponse(ctx context.Context, params *TxsParams, reqEditors ...RequestEditorFn) (*TxsResponse, error) {
	rsp, err := c.Txs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTxsResponse(rsp)
}

// WithdrawHistoryWithResponse request returning *WithdrawHistoryResponse
func (c *ClientWithResponses) WithdrawHistoryWithResponse(ctx context.Context, params *WithdrawHistoryParams, reqEditors ...RequestEditorFn) (*WithdrawHistoryResponse, error) {
	rsp, err := c.WithdrawHistory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawHistoryResponse(rsp)
}

// WithdrawalDelayWithResponse request returning *WithdrawalDelayResponse
func (c *ClientWithResponses) WithdrawalDelayWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WithdrawalDelayResponse, error) {
	rsp, err := c.WithdrawalDelay(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawalDelayResponse(rsp)
}

// InfoWithResponse request returning *InfoResponse
func (c *ClientWithResponses) InfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoResponse, error) {
	rsp, err := c.Info(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInfoResponse(rsp)
}

// ParseStatusResponse parses an HTTP response from a StatusWithResponse call
func ParseStatusResponse(rsp *http.Response) (*StatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountResponse parses an HTTP response from a AccountWithResponse call
func ParseAccountResponse(rsp *http.Response) (*AccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DetailedAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountActiveOrdersResponse parses an HTTP response from a AccountActiveOrdersWithResponse call
func ParseAccountActiveOrdersResponse(rsp *http.Response) (*AccountActiveOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountActiveOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Orders
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountInactiveOrdersResponse parses an HTTP response from a AccountInactiveOrdersWithResponse call
func ParseAccountInactiveOrdersResponse(rsp *http.Response) (*AccountInactiveOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountInactiveOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Orders
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountLimitsResponse parses an HTTP response from a AccountLimitsWithResponse call
func ParseAccountLimitsResponse(rsp *http.Response) (*AccountLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountLimits
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountMetadataResponse parses an HTTP response from a AccountMetadataWithResponse call
func ParseAccountMetadataResponse(rsp *http.Response) (*AccountMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountMetadatas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountTxsResponse parses an HTTP response from a AccountTxsWithResponse call
func ParseAccountTxsResponse(rsp *http.Response) (*AccountTxsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountTxsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Txs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAccountsByL1AddressResponse parses an HTTP response from a AccountsByL1AddressWithResponse call
func ParseAccountsByL1AddressResponse(rsp *http.Response) (*AccountsByL1AddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AccountsByL1AddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubAccounts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAnnouncementResponse parses an HTTP response from a AnnouncementWithResponse call
func ParseAnnouncementResponse(rsp *http.Response) (*AnnouncementResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AnnouncementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Announcements
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseApikeysResponse parses an HTTP response from a ApikeysWithResponse call
func ParseApikeysResponse(rsp *http.Response) (*ApikeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApikeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountApiKeys
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBlockResponse parses an HTTP response from a BlockWithResponse call
func ParseBlockResponse(rsp *http.Response) (*BlockResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blocks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBlockTxsResponse parses an HTTP response from a BlockTxsWithResponse call
func ParseBlockTxsResponse(rsp *http.Response) (*BlockTxsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlockTxsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Txs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBlocksResponse parses an HTTP response from a BlocksWithResponse call
func ParseBlocksResponse(rsp *http.Response) (*BlocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BlocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blocks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCandlesticksResponse parses an HTTP response from a CandlesticksWithResponse call
func ParseCandlesticksResponse(rsp *http.Response) (*CandlesticksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CandlesticksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Candlesticks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseChangeAccountTierResponse parses an HTTP response from a ChangeAccountTierWithResponse call
func ParseChangeAccountTierResponse(rsp *http.Response) (*ChangeAccountTierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeAccountTierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespChangeAccountTier
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCurrentHeightResponse parses an HTTP response from a CurrentHeightWithResponse call
func ParseCurrentHeightResponse(rsp *http.Response) (*CurrentHeightResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentHeightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrentHeight
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDepositHistoryResponse parses an HTTP response from a DepositHistoryWithResponse call
func ParseDepositHistoryResponse(rsp *http.Response) (*DepositHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DepositHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DepositHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseExchangeStatsResponse parses an HTTP response from a ExchangeStatsWithResponse call
func ParseExchangeStatsResponse(rsp *http.Response) (*ExchangeStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExchangeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseExportResponse parses an HTTP response from a ExportWithResponse call
func ParseExportResponse(rsp *http.Response) (*ExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFastbridgeInfoResponse parses an HTTP response from a FastbridgeInfoWithResponse call
func ParseFastbridgeInfoResponse(rsp *http.Response) (*FastbridgeInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FastbridgeInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespGetFastBridgeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFundingRatesResponse parses an HTTP response from a FundingRatesWithResponse call
func ParseFundingRatesResponse(rsp *http.Response) (*FundingRatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FundingRatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FundingRates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseFundingsResponse parses an HTTP response from a FundingsWithResponse call
func ParseFundingsResponse(rsp *http.Response) (*FundingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FundingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Fundings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseL1MetadataResponse parses an HTTP response from a L1MetadataWithResponse call
func ParseL1MetadataResponse(rsp *http.Response) (*L1MetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &L1MetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest L1Metadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseLiquidationsResponse parses an HTTP response from a LiquidationsWithResponse call
func ParseLiquidationsResponse(rsp *http.Response) (*LiquidationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiquidationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LiquidationInfos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseNextNonceResponse parses an HTTP response from a NextNonceWithResponse call
func ParseNextNonceResponse(rsp *http.Response) (*NextNonceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NextNonceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NextNonce
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseNotificationAckResponse parses an HTTP response from a NotificationAckWithResponse call
func ParseNotificationAckResponse(rsp *http.Response) (*NotificationAckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NotificationAckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOrderBookDetailsResponse parses an HTTP response from a OrderBookDetailsWithResponse call
func ParseOrderBookDetailsResponse(rsp *http.Response) (*OrderBookDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderBookDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderBookDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOrderBookOrdersResponse parses an HTTP response from a OrderBookOrdersWithResponse call
func ParseOrderBookOrdersResponse(rsp *http.Response) (*OrderBookOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderBookOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderBookOrders
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseOrderBooksResponse parses an HTTP response from a OrderBooksWithResponse call
func ParseOrderBooksResponse(rsp *http.Response) (*OrderBooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrderBooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderBooks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePnlResponse parses an HTTP response from a PnlWithResponse call
func ParsePnlResponse(rsp *http.Response) (*PnlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PnlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountPnL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePositionFundingResponse parses an HTTP response from a PositionFundingWithResponse call
func ParsePositionFundingResponse(rsp *http.Response) (*PositionFundingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PositionFundingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PositionFundings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePublicPoolsResponse parses an HTTP response from a PublicPoolsWithResponse call
func ParsePublicPoolsResponse(rsp *http.Response) (*PublicPoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicPoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicPools
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePublicPoolsMetadataResponse parses an HTTP response from a PublicPoolsMetadataWithResponse call
func ParsePublicPoolsMetadataResponse(rsp *http.Response) (*PublicPoolsMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublicPoolsMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespPublicPoolsMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRecentTradesResponse parses an HTTP response from a RecentTradesWithResponse call
func ParseRecentTradesResponse(rsp *http.Response) (*RecentTradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecentTradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Trades
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseReferralPointsResponse parses an HTTP response from a ReferralPointsWithResponse call
func ParseReferralPointsResponse(rsp *http.Response) (*ReferralPointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReferralPointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReferralPoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSendTxResponse parses an HTTP response from a SendTxWithResponse call
func ParseSendTxResponse(rsp *http.Response) (*SendTxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendTxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespSendTx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSendTxBatchResponse parses an HTTP response from a SendTxBatchWithResponse call
func ParseSendTxBatchResponse(rsp *http.Response) (*SendTxBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SendTxBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespSendTxBatch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTradesResponse parses an HTTP response from a TradesWithResponse call
func ParseTradesResponse(rsp *http.Response) (*TradesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TradesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Trades
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTransferHistoryResponse parses an HTTP response from a TransferHistoryWithResponse call
func ParseTransferHistoryResponse(rsp *http.Response) (*TransferHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTransferFeeInfoResponse parses an HTTP response from a TransferFeeInfoWithResponse call
func ParseTransferFeeInfoResponse(rsp *http.Response) (*TransferFeeInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferFeeInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransferFeeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTxResponse parses an HTTP response from a TxWithResponse call
func ParseTxResponse(rsp *http.Response) (*TxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedTx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTxFromL1TxHashResponse parses an HTTP response from a TxFromL1TxHashWithResponse call
func ParseTxFromL1TxHashResponse(rsp *http.Response) (*TxFromL1TxHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TxFromL1TxHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnrichedTx
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseTxsResponse parses an HTTP response from a TxsWithResponse call
func ParseTxsResponse(rsp *http.Response) (*TxsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TxsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Txs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseWithdrawHistoryResponse parses an HTTP response from a WithdrawHistoryWithResponse call
func ParseWithdrawHistoryResponse(rsp *http.Response) (*WithdrawHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WithdrawHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseWithdrawalDelayResponse parses an HTTP response from a WithdrawalDelayWithResponse call
func ParseWithdrawalDelayResponse(rsp *http.Response) (*WithdrawalDelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawalDelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RespWithdrawalDelay
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInfoResponse parses an HTTP response from a InfoWithResponse call
func ParseInfoResponse(rsp *http.Response) (*InfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZkLighterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResultCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
